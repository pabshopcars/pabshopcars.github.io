<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Car ‚Äî PAB SHOP</title>
  <meta name="description" content="Car for sale - PAB SHOP">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <meta name="google-site-verification" content="evnpLoU4TEYreEXpPrIDMKN0ASQL9bB6PMvvnywPwNU" />
  
<style>
  :root{
    --bg:#f6f7fb;
    --card:#ffffff;
    --muted:#6b7280;
    --text:#0f1724;
    --accent:#0b6eff;
    --glass:rgba(255,255,255,0.65);
    --shadow:0 6px 20px rgba(12,15,20,0.06);
    --border:rgba(0,0,0,0.04);

    --graybtn-bg:rgba(15,23,36,0.06);
    --graybtn-bg-hover:rgba(15,23,36,0.10);
    --graybtn-border:rgba(15,23,36,0.10);
    --warn: #ff4d4d;
    --ok: #10b981;
  }
  [data-theme="dark"]{
    --bg:#0b0f16;
    --card:#0f1724;
    --muted:#94a3b8;
    --text:#e6eef8;
    --accent:#4ea8ff;
    --glass:rgba(255,255,255,0.05);
    --shadow:0 10px 30px rgba(0,0,0,0.6);
    --border:rgba(255,255,255,0.03);

    --graybtn-bg:rgba(255,255,255,0.06);
    --graybtn-bg-hover:rgba(255,255,255,0.10);
    --graybtn-border:rgba(255,255,255,0.10);
  }

  *{box-sizing:border-box;margin:0;padding:0}
  body{
    font-family:Inter,system-ui;
    background:var(--bg);
    color:var(--text);
    transition:background 0.4s ease, color 0.4s ease;
    line-height:1.6;
  }
  .container{max-width:1200px;margin:0 auto;padding:0 20px}

  header .container{ padding:10px 20px; }
  header{
    position:sticky; top:0; z-index:100;
    backdrop-filter:blur(12px) saturate(180%);
    background:var(--glass);
    border-bottom:1px solid var(--border);
    transition:all 0.4s ease;
  }
  .header-inner{
    display:flex; justify-content:space-between; align-items:center; padding:16px 0;
  }
  .logo{
    font-weight:700; color:var(--accent); font-size:22px; letter-spacing:-0.5px; text-decoration:none;
  }
  nav{display:flex;gap:8px;align-items:center}
  nav a{
    padding:10px 16px; color:var(--muted); text-decoration:none; font-weight:600;
    border-radius:8px; transition:all 0.3s cubic-bezier(0.4,0,0.2,1); font-size:15px;
  }
  nav a:hover{ color:var(--text); background:var(--glass); transform:translateY(-1px); }

  .settings-toggle{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:50%;
    padding:10px; width:44px; height:44px;
    cursor:pointer; display:flex; align-items:center; justify-content:center;
    color:var(--text);
    transition:all 0.3s cubic-bezier(0.4,0,0.2,1);
    box-shadow:var(--shadow);
  }
  .settings-toggle:hover{ transform:scale(1.08); box-shadow:0 8px 25px rgba(0,0,0,0.1); }
  .settings-toggle:active{transform:scale(0.98)}
  .settings-icon{font-size:20px;transition:transform 0.6s ease}
  .settings-toggle:hover .settings-icon{transform:rotate(90deg)}

  .settings-overlay{
    position:fixed; top:0; left:0; width:100%; height:100%;
    background:rgba(0,0,0,0.5);
    backdrop-filter:blur(4px);
    z-index:1000;
    display:flex; align-items:center; justify-content:center;
    opacity:0; pointer-events:none; transition:opacity 0.3s ease;
  }
  .settings-overlay.active{ opacity:1; pointer-events:all; }
  .settings-modal{
    background:var(--card);
    border-radius:20px;
    padding:32px;
    box-shadow:0 20px 60px rgba(0,0,0,0.3);
    border:1px solid var(--border);
    max-width:500px; width:90%;
    transform:scale(0.8) translateY(-20px);
    transition:transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
  }
  .settings-overlay.active .settings-modal{ transform:scale(1) translateY(0); }
  .settings-header{ display:flex; justify-content:space-between; align-items:center; margin-bottom:28px; }
  .settings-header h2{ font-size:26px; color:var(--text); font-weight:700; }
  .close-btn{
    background:none; border:none; font-size:28px; color:var(--muted); cursor:pointer;
    transition:all 0.2s ease;
    width:36px; height:36px;
    display:flex; align-items:center; justify-content:center;
    border-radius:8px;
  }
  .close-btn:hover{ background:var(--glass); color:var(--text); transform:rotate(90deg); }

  .settings-section{ margin-bottom:28px; }
  .settings-section:last-child{ margin-bottom:0; }
  .settings-section h3{
    font-size:16px; color:var(--text); margin-bottom:14px; font-weight:700;
    text-transform:uppercase; letter-spacing:0.5px; opacity:0.8;
  }
  .theme-buttons{ display:flex; gap:12px; }
  .theme-btn{
    flex:1; padding:16px;
    border:2px solid var(--border);
    border-radius:12px;
    background:var(--card);
    cursor:pointer;
    transition:all 0.3s ease;
    font-weight:600;
    font-size:15px;
    color:var(--text);
    display:flex; align-items:center; justify-content:center; gap:8px;
  }
  .theme-btn:hover{ transform:translateY(-2px); box-shadow:0 8px 20px rgba(0,0,0,0.1); }
  .theme-btn.active{ border-color:var(--accent); background:var(--accent); color:#fff; }

  .back-link{
    display:inline-flex; align-items:center; gap:8px;
    color:var(--muted); text-decoration:none; font-weight:600;
    margin:30px 0 20px;
    transition:all 0.3s ease; font-size:15px;
  }
  .back-link:hover{ color:var(--accent); transform:translateX(-4px); }

  .car-detail{ padding:20px 0 60px; }

  .car-header{ margin-bottom:40px; }
  .car-header h1{
    font-size:clamp(32px,5vw,48px);
    margin:0 0 16px;
    font-weight:700;
    letter-spacing:-1px;
  }
  .car-price{ font-size:36px; color:var(--accent); font-weight:700; margin-bottom:8px; }
  .car-meta{ color:var(--muted); font-size:18px; }


  /* Header inline-edit inputs (title + price) */
  .car-header-input{
    width:100%;
    max-width:100%; /* CHANGED: was 520px */
    margin:0 0 12px;
    text-align:left !important; /* you explicitly want left */
    padding:10px 12px;
    border-radius:12px;
    border:1px solid transparent;
    background:transparent;
    color:var(--text);
    font-weight:800;
    font-size:clamp(28px,4.6vw,46px);
    letter-spacing:-1px;
  }

  /* CHANGED: make title bigger in edit mode */
  #carTitleInput.car-header-input{
    font-size:clamp(32px,5vw,48px);
    max-width:100%;
  }

  /* CHANGED: price width matches title */
  #carPriceInput.car-header-input{
    max-width:100%; /* CHANGED: was 280px */
    font-size:36px;
    letter-spacing:-0.5px;
    color:var(--accent);
  }

  .car-header-input.editing{
    border-color:var(--border);
    background:var(--glass);
  }

  .car-header-input.changed{
    border-color:rgba(11,110,255,0.45);
    background:rgba(11,110,255,0.08);
    box-shadow:0 10px 24px rgba(11,110,255,0.10);
  }


  .content-grid{
    display:grid;
    grid-template-columns:2fr 1fr;
    gap:40px;
    margin-bottom:60px;
  }

  .gallery{
    background:var(--card);
    border-radius:16px;
    overflow:hidden;
    box-shadow:var(--shadow);
    border:1px solid var(--border);
    position:relative;
  }
  .main-img{
    width:100%;
    height:500px;
    object-fit:contain;
    background:var(--bg);
    cursor:pointer;
    /* JS controls transforms for swipe */
    transition:none;
  }

  /* Swipe gallery: during drag you can see the next/prev image underneath (Marketplace-style) */
  .main-media{ position:relative; overflow:hidden; touch-action:pan-y; }
  .swipe-ghost{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    object-fit:contain;
    /* Transparent background so the fullscreen ghost inherits the
       overlay backdrop instead of showing a card colour */
    background:var(--bg);
    pointer-events:none;
    opacity:0;
  }

  /* Ensure the swipe ghost inside the fullscreen overlay uses a
     transparent background.  Without this override the ghost can
     inadvertently show the page colour during transitions. */
  .fullscreen-overlay .swipe-ghost{
    background:transparent;
  }
  /* Adjust the duration of the swipe animation to slow down the slide
     transitions.  A longer duration provides a smoother, less abrupt
     transition between images. */
  .swipe-anim{ transition: transform 250ms ease; }

  .slider-btn{
    position:absolute; top:50%;
    transform:translateY(-50%);
    background:rgba(255,255,255,0.9);
    border:none;
    width:50px; height:50px;
    border-radius:50%;
    cursor:pointer;
    font-size:24px;
    display:none;
    align-items:center; justify-content:center;
    transition:all 0.3s ease;
    box-shadow:0 4px 12px rgba(0,0,0,0.15);
    z-index:10;
  }
  .slider-btn:hover{ background:rgba(255,255,255,1); transform:translateY(-50%) scale(1.1); }
  .slider-btn:active{ transform:translateY(-50%) scale(0.95); }
  .slider-btn.prev{left:15px}
  .slider-btn.next{right:15px}
  [data-theme="dark"] .slider-btn{ background:rgba(255,255,255,0.15); color:#fff; }
  [data-theme="dark"] .slider-btn:hover{ background:rgba(255,255,255,0.25); }

  .slider-dots{
    position:absolute; top:50%;
    transform:translateY(-50%);
    right:20px;
    display:none;
    flex-direction:column;
    gap:8px;
    z-index:10;
  }
  .dot{
    width:10px; height:10px;
    border-radius:50%;
    background:rgba(255,255,255,0.5);
    cursor:pointer;
    transition:all 0.3s ease;
  }
  .dot.active{
    background:rgba(255,255,255,1);
    height:24px;
    border-radius:5px;
  }

  /* Fullscreen modal (USER VIEW) */
  .fullscreen-overlay{
    /* Fixed full-screen overlay covering the entire viewport.  Use a
       solid black backdrop like the reference video.  Align items
       to the top and centre horizontally so the image sits below
       the header (close button and counter). */
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background:#000;
    z-index:2000;
    display:none;
    /* Center content vertically in fullscreen mode so the image appears
       centered regardless of header overlay.  This change aligns
       items to the center instead of the top without affecting other
       properties. */
    align-items:center;
    justify-content:center;
    opacity:0;
    transition:opacity 0.3s ease;
    /* Disable default touch actions (like scrolling) so that drag
       gestures don't scroll the page behind the overlay. */
    touch-action:none;
  }
  .fullscreen-overlay.active{ display:flex; opacity:1; }
  .fullscreen-img{
    /* Make the fullscreen image fill the available space while
       reserving vertical room for the header.  Remove the default
       90% sizing so it can grow to full width. */
    max-width:100%;
    max-height:100%;
    margin-top:0;
    object-fit:contain;
  }
  .fullscreen-close{
    /* Simplify the close button: move it to the top-left corner,
       remove decorative backgrounds and borders, and display a plain
       white √ó glyph. */
    position:absolute;
    top:20px;
    left:20px;
    font-size:32px;
    color:#fff;
    cursor:pointer;
    background:none;
    border:none;
    width:auto;
    height:auto;
    border-radius:0;
    display:block;
    line-height:1;
    z-index:2001;
    transition:color 0.3s ease;
  }
  .fullscreen-close:hover{
    /* Lighten the icon slightly on hover without rotating it. */
    color:#aaa;
  }
  .fullscreen-nav{
    /* Hide navigation arrows in fullscreen mode by default.  They
       will be made visible on larger screens via media queries
       below. */
    display:none;
  }
  .fullscreen-nav:hover{}
  .fullscreen-nav:active{}
  .fullscreen-nav.prev{}
  .fullscreen-nav.next{}
  .fullscreen-counter{
    /* Place the slide counter at the top centre with no extra
       decoration.  Use simple white text and remove gradient
       backgrounds, borders and drop shadows. */
    position:absolute;
    top:20px;
    left:50%;
    transform:translateX(-50%);
    background:none;
    color:#fff;
    padding:0;
    border-radius:0;
    font-size:16px;
    font-weight:400;
    z-index:2001;
    box-shadow:none;
    letter-spacing:normal;
  }

  /* Thumbs (saved images only) */
  .thumbs{
    display:grid;
    grid-template-columns:repeat(4,1fr);
    gap:12px;
    padding:20px;
    background:var(--bg);
  }
  .thumb{
    aspect-ratio:4/3;
    border-radius:10px;
    overflow:hidden;
    cursor:pointer;
    border:3px solid transparent;
    transition:all 0.3s ease;
    position:relative;
    background:var(--card);
  }
  .thumb:hover{ border-color:var(--accent); transform:scale(1.03); }
  .thumb.active{ border-color:var(--accent); }
  .thumb img{ width:100%; height:100%; object-fit:cover; display:block; }

  /* cover badge on thumb (admin only visibility handled by JS) */
  .thumb-cover-badge{
    position:absolute;
    left:10px; bottom:10px;
    background:rgba(0,0,0,0.7);
    color:#fff;
    padding:6px 10px;
    border-radius:10px;
    font-size:12px;
    font-weight:800;
    letter-spacing:1px;
    border:1px solid rgba(255,255,255,0.18);
    display:none;
    user-select:none;
  }

  /* pending (selected but not uploaded yet) */
  .thumb.pending{
    border-color:rgba(255,77,77,0.6);
  }
  .thumb.pending:hover{
    border-color:rgba(255,77,77,0.9);
  }
  .thumb-remove{
    position:absolute;
    top:8px; right:8px;
    width:34px; height:34px;
    border-radius:10px;
    border:1px solid rgba(255,77,77,0.35);
    background:rgba(255,77,77,0.18);
    color:#ff4d4d;
    cursor:pointer;
    display:flex; align-items:center; justify-content:center;
    font-weight:900;
    font-size:16px;
    box-shadow:0 6px 16px rgba(0,0,0,0.18);
    display:none;
  }
  .thumb-remove:hover{
    background:rgba(255,77,77,0.28);
    transform:scale(1.05);
  }

  /* upload tile */
  .admin-upload-tile{
    aspect-ratio:4/3;
    border-radius:10px;
    border:2px dashed var(--border);
    background:var(--card);
    display:flex; align-items:center; justify-content:center;
    cursor:pointer;
    transition:all 0.25s ease;
    position:relative;
    overflow:hidden;
  }
  .admin-upload-tile:hover{
    border-color:var(--accent);
    transform:scale(1.03);
    box-shadow:0 10px 24px rgba(0,0,0,0.12);
  }
  .admin-upload-tile .icon{
    width:58px; height:58px;
    border-radius:18px;
    display:flex; align-items:center; justify-content:center;
    background:linear-gradient(135deg,var(--accent),#2b8fff);
    color:#fff;
    font-size:26px;
    box-shadow:0 10px 28px rgba(11,110,255,0.35);
  }
  .admin-upload-tile .label{
    position:absolute;
    bottom:10px; left:50%;
    transform:translateX(-50%);
    font-size:12px;
    color:var(--muted);
    font-weight:700;
    letter-spacing:0.6px;
    text-transform:uppercase;
    background:var(--glass);
    border:1px solid var(--border);
    padding:5px 10px;
    border-radius:999px;
    backdrop-filter: blur(10px);
  }

  /* upload commit tile */
  .admin-commit-tile{
    aspect-ratio:4/3;
    border-radius:10px;
    border:1px solid var(--border);
    background:linear-gradient(135deg,rgba(16,185,129,0.18),rgba(5,150,105,0.10));
    display:flex; align-items:center; justify-content:center;
    cursor:pointer;
    transition:all 0.25s ease;
    position:relative;
    overflow:hidden;
  }
  .admin-commit-tile:hover{
    transform:scale(1.03);
    box-shadow:0 10px 24px rgba(0,0,0,0.12);
    border-color:rgba(16,185,129,0.35);
  }
  .admin-commit-tile .icon{
    width:58px; height:58px;
    border-radius:18px;
    display:flex; align-items:center; justify-content:center;
    background:linear-gradient(135deg,#10b981,#059669);
    color:#fff;
    font-size:22px;
    box-shadow:0 10px 28px rgba(16,185,129,0.28);
  }
  .admin-commit-tile .label{
    position:absolute;
    bottom:10px; left:50%;
    transform:translateX(-50%);
    font-size:12px;
    color:var(--muted);
    font-weight:800;
    letter-spacing:0.6px;
    text-transform:uppercase;
    background:var(--glass);
    border:1px solid var(--border);
    padding:5px 10px;
    border-radius:999px;
    backdrop-filter: blur(10px);
  }

  /* admin-only divider under thumbs */
  .admin-divider{
    height:1px;
    margin:0 20px;
    background:var(--border);
  }

  .admin-tools-row{
    padding:16px 20px 12px;
    background:var(--bg);
  }
  .admin-pending-row{
    padding:12px 20px 20px;
    background:var(--bg);
  }

  .sidebar{ display:flex; flex-direction:column; gap:24px; }
  .info-card{
    background:var(--card);
    border-radius:16px;
    padding:28px;
    box-shadow:var(--shadow);
    border:1px solid var(--border);
  }
  .info-card h3{ margin:0 0 20px; font-size:20px; font-weight:700; }

  .spec-list{ display:flex; flex-direction:column; gap:16px; }
  .spec-item{
    display:flex;
    justify-content:space-between;
    padding-bottom:12px;
    border-bottom:1px solid var(--border);
    align-items:flex-start;
    gap:12px;
  }
  .spec-item:last-child{ border:0; padding-bottom:0; }
  .spec-label{
    color:var(--muted);
    font-size:15px;
    display:flex;
    align-items:center;
    gap:10px;
    min-width:120px;
  }
  .spec-icon{
    font-size:18px;
    color:var(--accent);
    width:24px;
    text-align:center;
    opacity:0.9;
  }
  .spec-value{
    font-weight:600;
    text-align:right;
    max-width:60%;
  }

  /* Inline editable value (admin) */
  .spec-input{
    width:100%;
    max-width:260px;
    text-align:right;
    padding:8px 10px;
    border-radius:10px;
    border:1px solid transparent;
    background:transparent;
    color:var(--text);
    font-weight:700;
    outline:none;
  }
  .spec-input[disabled]{
    opacity:1;
    cursor:default;
  }
  .spec-input.editing{
    border-color:var(--border);
    background:var(--glass);
  }
  .spec-input.changed{
    border-color:rgba(11,110,255,0.45);
    background:rgba(11,110,255,0.08);
    box-shadow:0 10px 24px rgba(11,110,255,0.10);
  }
  [data-theme="dark"] .spec-input.changed{
    background:rgba(78,168,255,0.10);
    box-shadow:0 10px 24px rgba(0,0,0,0.25);
  }
  .spec-was{
    display:none;
    margin-top:6px;
    font-size:12px;
    color:var(--muted);
    text-align:right;
  }
  .spec-was.show{
    display:block;
  }

  /* Description inline editable */
  .desc-textarea{
    width:100%;
    min-height:140px;
    padding:12px;
    border-radius:12px;
    border:1px solid transparent;
    background:transparent;
    color:var(--text);
    resize:vertical;
    outline:none;
  }
  .desc-textarea.editing{
    border-color:var(--border);
    background:var(--glass);
  }
  .desc-textarea.changed{
    border-color:rgba(11,110,255,0.45);
    background:rgba(11,110,255,0.08);
    box-shadow:0 10px 24px rgba(11,110,255,0.10);
  }

  /* Inline edit controls (admin only) */
  .inline-edit-controls{
    padding:0;
    margin-top:16px;
  }
  .inline-edit-row{
    display:flex;
    gap:10px;
    width:100%;
    flex-wrap:wrap;
  }

  /* ====== CHANGED: Edit/Save styled like contact + sold/delete ====== */
  .admin-edit-btn{
    flex:3;
    border:none;
    border-radius:12px;
    padding:18px 24px;
    font-weight:800;
    font-size:16px;
    cursor:pointer;
    transition:all 0.3s cubic-bezier(0.4,0,0.2,1);
    box-shadow:0 4px 15px rgba(0,0,0,0.18);
    background:linear-gradient(135deg, rgba(15,23,36,0.10), rgba(15,23,36,0.18));
    color:var(--text);
  }
  .admin-edit-btn:hover{
    transform:translateY(-3px);
    box-shadow:0 8px 25px rgba(0,0,0,0.22);
    background:linear-gradient(135deg, rgba(15,23,36,0.14), rgba(15,23,36,0.24));
  }
  .admin-edit-btn:active{ transform:translateY(-1px); }

  /* lighter shade of black in dark theme */
  [data-theme="dark"] .admin-edit-btn{
    background:linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.14));
    color:#fff;
    box-shadow:0 4px 15px rgba(0,0,0,0.35);
  }
  [data-theme="dark"] .admin-edit-btn:hover{
    background:linear-gradient(135deg, rgba(255,255,255,0.10), rgba(255,255,255,0.18));
    box-shadow:0 8px 25px rgba(0,0,0,0.45);
  }

  /* Save: different green shade than contact email */
  .admin-save-btn{
    flex:1;
    border:none;
    border-radius:12px;
    padding:18px 24px;
    font-weight:900;
    font-size:16px;
    cursor:pointer;
    transition:all 0.3s cubic-bezier(0.4,0,0.2,1);
    color:#fff;
    background:linear-gradient(135deg,#34d399,#0ea5a4);
    box-shadow:0 4px 15px rgba(14,165,164,0.28);
  }
  .admin-save-btn:hover{
    transform:translateY(-3px);
    box-shadow:0 8px 25px rgba(14,165,164,0.38);
  }
  .admin-save-btn:active{ transform:translateY(-1px); }
  .admin-save-btn:disabled{
    opacity:0.65;
    cursor:not-allowed;
    transform:none;
  }
  /* ====== end changed ====== */
  .inline-status{
    margin-top:10px;
    color:var(--muted);
    font-size:13px;
  }

  .description{
    background:var(--card);
    border-radius:16px;
    padding:32px;
    box-shadow:var(--shadow);
    border:1px solid var(--border);
    margin-bottom:40px;
  }
  .description h2{ margin:0 0 14px; font-size:28px; font-weight:700; }
  .description p{ color:var(--muted); font-size:16px; line-height:1.8; margin-bottom:16px; }

  #contact{ padding:60px 0; text-align:center; }
  #contact h2{ color:var(--text); margin-bottom:16px; font-size:32px; font-weight:700; }
  #contact p{ color:var(--muted); font-size:16px; margin-bottom:24px; }
  .contact-buttons{
    display:flex;
    gap:16px;
    max-width:600px;
    margin:0 auto;
    justify-content:center;
    flex-direction:column;
    padding:0;
  }
  .contact-btn{
    display:inline-block;
    padding:18px 32px;
    background:linear-gradient(135deg,var(--accent),#2b8fff);
    color:#fff;
    text-align:center;
    text-decoration:none;
    font-weight:700;
    font-size:18px;
    border-radius:12px;
    transition:all 0.3s cubic-bezier(0.4,0,0.2,1);
    box-shadow:0 4px 15px rgba(11,110,255,0.3);
    width:100%;
    min-width:auto;
  }
  .contact-btn:hover{ transform:translateY(-3px); box-shadow:0 8px 25px rgba(11,110,255,0.4); }
  .contact-btn.email{
    background:linear-gradient(135deg,#10b981,#059669);
    box-shadow:0 4px 15px rgba(16,185,129,0.3);
  }
  .contact-btn.email:hover{ box-shadow:0 8px 25px rgba(16,185,129,0.4); }
  .contact-btn.secondary{
    background: var(--card);
    color: var(--accent);
    border: 2px solid var(--accent);
    box-shadow: var(--shadow);
  }
  .contact-btn.secondary:hover{ background: var(--glass); transform: translateY(-3px); }

  /* Admin action buttons styled like contact buttons */
  .action-buttons{
    display:flex;
    gap:16px;
    width:100%;
    padding:0;
  }

  .action-btn{
    flex:1;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    padding:18px 24px;
    text-decoration:none;
    font-weight:800;
    font-size:16px;
    border-radius:12px;
    cursor:pointer;
    border:none;
    transition:all 0.3s cubic-bezier(0.4,0,0.2,1);
    box-shadow:0 4px 15px rgba(0,0,0,0.18);
  }

  .action-btn:hover{
    transform:translateY(-3px);
    box-shadow:0 8px 25px rgba(0,0,0,0.22);
  }

  .action-btn:active{
    transform:translateY(-1px);
  }

  /* Yellow "Mark Sold" */
  .action-btn.sold{
    background:linear-gradient(135deg,#fbbf24,#f59e0b);
    color:#111827;
    box-shadow:0 4px 15px rgba(245,158,11,0.35);
  }
  .action-btn.sold:hover{
    box-shadow:0 8px 25px rgba(245,158,11,0.45);
  }

  /* Red "Delete" */
  .action-btn.delete{
    background:linear-gradient(135deg,#ff4d4d,#dc2626);
    color:#fff;
    box-shadow:0 4px 15px rgba(220,38,38,0.35);
  }
  .action-btn.delete:hover{
    box-shadow:0 8px 25px rgba(220,38,38,0.45);
  }

  footer{
    text-align:center;
    padding:40px 0;
    color:var(--muted);
    border-top:1px solid var(--border);
    margin-top:60px;
    font-size:14px;
  }

  /* admin view buttons */
  .view-btn-active{
    background: linear-gradient(135deg, var(--accent), #2b8fff);
    color: #fff;
    border-color: transparent;
    box-shadow: 0 6px 18px rgba(11,110,255,0.35);
  }
  .view-btn-inactive{
    background: var(--card);
    color: var(--muted);
    border: 2px solid var(--border);
  }

  /* Admin Photo Modal (not fullscreen) */
  .admin-photo-overlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.55);
    backdrop-filter:blur(3px);
    z-index:3000;
    display:none;
    align-items:center;
    justify-content:center;
    padding:20px;
  }
  .admin-photo-modal{
    width:min(920px,95vw);
    background:var(--card);
    border:1px solid var(--border);
    border-radius:18px;
    box-shadow:var(--shadow);
    padding:18px;
    position:relative;
  }
  .admin-photo-close{
    position:absolute;
    top:10px; right:12px;
    width:38px; height:38px;
    border-radius:10px;
    border:1px solid var(--border);
    background:var(--glass);
    color:var(--text);
    font-size:24px;
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .admin-photo-wrap{
    position:relative;
    background:var(--bg);
    border-radius:14px;
    border:1px solid var(--border);
    overflow:hidden;
    display:flex;
    align-items:center;
    justify-content:center;
    max-height:70vh;
  }
  .admin-photo-wrap img{
    width:100%;
    height:auto;
    max-height:70vh;
    object-fit:contain;
  }
  .admin-photo-delete{
    position:absolute;
    top:12px; right:12px;
    width:46px; height:46px;
    border-radius:14px;
    border:1px solid rgba(255,77,77,0.35);
    background:rgba(255,77,77,0.18);
    color:#ff4d4d;
    cursor:pointer;
    font-size:18px;
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow:0 10px 24px rgba(0,0,0,0.22);
  }
  .admin-photo-delete:hover{ background:rgba(255,77,77,0.28); transform:scale(1.05); }
  .admin-photo-cover{
    position:absolute;
    left:12px; bottom:12px;
    padding:10px 14px;
    border-radius:14px;
    border:1px solid var(--border);
    background:linear-gradient(135deg,var(--accent),#2b8fff);
    color:#fff;
    font-weight:800;
    cursor:pointer;
    box-shadow:0 10px 24px rgba(11,110,255,0.25);
  }
  .admin-photo-cover:hover{ transform:scale(1.03); }
  .admin-cover-badge{
    position:absolute;
    left:12px; top:12px;
    background:rgba(0,0,0,0.70);
    color:#fff;
    padding:6px 10px;
    border-radius:10px;
    font-size:12px;
    font-weight:900;
    letter-spacing:1px;
    border:1px solid rgba(255,255,255,0.18);
    display:none;
    user-select:none;
  }

  /* ====== NEW: Styled confirm modal (replaces confirm() for sold/delete/discard) ====== */
  .pab-confirm-overlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.55);
    backdrop-filter:blur(4px);
    z-index:5000;
    display:none;
    align-items:center;
    justify-content:center;
    padding:20px;
  }
  .pab-confirm-modal{
    width:min(560px, 95vw);
    background:var(--card);
    border:1px solid var(--border);
    border-radius:18px;
    box-shadow:0 20px 60px rgba(0,0,0,0.35);
    overflow:hidden;
    transform:scale(0.95) translateY(10px);
    opacity:0;
    transition:transform 0.2s ease, opacity 0.2s ease;
  }
  .pab-confirm-overlay.active{ display:flex; }
  .pab-confirm-overlay.active .pab-confirm-modal{
    transform:scale(1) translateY(0);
    opacity:1;
  }
  @media (max-width: 768px){
    .spec-input,
    .desc-textarea,
    .car-header-input{
      font-size: 16px !important;
    }
  }
  .pab-confirm-btn.warn{
    background: linear-gradient(135deg,#fbbf24,#f59e0b);
    color:#111827;
    box-shadow:0 4px 15px rgba(245,158,11,0.35);
  }
  .pab-confirm-btn.warn:hover{
    transform:translateY(-2px);
    box-shadow:0 8px 25px rgba(245,158,11,0.45);
  }

  .pab-confirm-head{
    padding:18px 18px 12px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    border-bottom:1px solid var(--border);
    background:linear-gradient(135deg, rgba(11,110,255,0.08), rgba(11,110,255,0.03));
  }
  [data-theme="dark"] .pab-confirm-head{
    background:linear-gradient(135deg, rgba(78,168,255,0.12), rgba(255,255,255,0.03));
  }
  .pab-confirm-title{
    font-weight:900;
    letter-spacing:-0.3px;
    font-size:16px;
    color:var(--text);
    display:flex;
    align-items:center;
    gap:10px;
  }
  .pab-confirm-icon{
    width:34px; height:34px;
    border-radius:12px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:16px;
    background:var(--glass);
    border:1px solid var(--border);
    box-shadow:var(--shadow);
  }
  .pab-confirm-close{
    width:38px; height:38px;
    border-radius:12px;
    border:1px solid var(--border);
    background:var(--glass);
    color:var(--text);
    font-size:22px;
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    transition:transform 0.2s ease;
  }
  .pab-confirm-close:hover{ transform:rotate(90deg); }
  .pab-confirm-body{
    padding:16px 18px 0;
    color:var(--muted);
    font-size:15px;
    line-height:1.6;
  }
  .pab-confirm-actions{
    padding:18px;
    display:flex;
    gap:12px;
    justify-content:flex-end;
    flex-wrap:wrap;
  }
  .pab-confirm-btn{
    border:none;
    border-radius:12px;
    padding:12px 16px;
    font-weight:900;
    cursor:pointer;
    transition:all 0.25s cubic-bezier(0.4,0,0.2,1);
    box-shadow:0 4px 15px rgba(0,0,0,0.18);
    display:inline-flex;
    align-items:center;
    justify-content:center;
    gap:8px;
    min-width:120px;
    font-size:14px;
  }
  .pab-confirm-btn:active{ transform:translateY(-1px); }
  .pab-confirm-btn.cancel{
    background:linear-gradient(135deg, rgba(15,23,36,0.10), rgba(15,23,36,0.18));
    color:var(--text);
  }
  [data-theme="dark"] .pab-confirm-btn.cancel{
    background:linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.14));
    color:#fff;
    box-shadow:0 4px 15px rgba(0,0,0,0.35);
  }
  .pab-confirm-btn.cancel:hover{ transform:translateY(-2px); box-shadow:0 8px 25px rgba(0,0,0,0.22); }

  .pab-confirm-btn.ok{
    background:linear-gradient(135deg,var(--accent),#2b8fff);
    color:#fff;
    box-shadow:0 4px 15px rgba(11,110,255,0.35);
  }
  .pab-confirm-btn.ok:hover{ transform:translateY(-2px); box-shadow:0 8px 25px rgba(11,110,255,0.45); }

  .pab-confirm-btn.danger{
    background:linear-gradient(135deg,#ff4d4d,#dc2626);
    color:#fff;
    box-shadow:0 4px 15px rgba(220,38,38,0.35);
  }
  .pab-confirm-btn.danger:hover{ transform:translateY(-2px); box-shadow:0 8px 25px rgba(220,38,38,0.45); }
  /* ====== end confirm modal ====== */

  /* ====== NEW: Top edit (title + price) UI under header ====== */
  .top-edit-panel{
    margin-top:14px;
    background:var(--card);
    border:1px solid var(--border);
    border-radius:16px;
    padding:18px;
    box-shadow:var(--shadow);
  }
  .top-edit-grid{
    display:grid;
    grid-template-columns: 1fr 220px;
    gap:12px;
    align-items:start;
  }
  .top-edit-field{
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .top-edit-label{
    font-size:12px;
    text-transform:uppercase;
    letter-spacing:0.7px;
    color:var(--muted);
    font-weight:800;
    display:flex;
    gap:8px;
    align-items:center;
  }
  .top-edit-input{
    width:100%;
    max-width:none;
    text-align:left;
    padding:10px 12px;
    border-radius:12px;
    border:1px solid transparent;
    background:transparent;
    color:var(--text);
    font-weight:800;
    outline:none;
  }
  .top-edit-input.editing{
    border-color:var(--border);
    background:var(--glass);
  }
  .top-edit-input.changed{
    border-color:rgba(11,110,255,0.45);
    background:rgba(11,110,255,0.08);
    box-shadow:0 10px 24px rgba(11,110,255,0.10);
  }
  [data-theme="dark"] .top-edit-input.changed{
    background:rgba(78,168,255,0.10);
    box-shadow:0 10px 24px rgba(0,0,0,0.25);
  }
  .top-edit-was{
    display:none;
    font-size:12px;
    color:var(--muted);
  }
  .top-edit-was.show{ display:block; }

  @media(max-width:968px){
    .content-grid{ grid-template-columns:1fr; }
    .main-img{ height:400px; }
    .spec-value{ max-width:70%; }
    .top-edit-grid{ grid-template-columns:1fr; }
  }
  @media(max-width:768px){
    .header-inner{padding:12px 0}
    nav{display:flex; flex-wrap:wrap; justify-content:center; gap:6px;}
    nav a{padding:8px 14px; font-size:14px;}
    .car-price{font-size:28px}
    .main-img{height:350px}
    .thumbs{ grid-template-columns:repeat(3,1fr); gap:8px; padding:12px; }
    .admin-divider{ margin:0 12px; }
    .admin-tools-row{ padding:12px 12px 10px; }
    .admin-pending-row{ padding:10px 12px 14px; }
    .description{ padding:24px; }
    .settings-modal{ padding:24px }
    .slider-dots{ right:10px; }
    .top-edit-panel{ padding:14px; }
  }
  @media(max-width:480px){
    .logo{font-size:20px}
    .settings-toggle{padding:8px;width:40px;height:40px}
    .settings-icon{font-size:18px}
    .slider-btn{width:40px;height:40px;font-size:20px}
    .slider-btn.prev{left:10px}
    .slider-btn.next{right:10px}
    .main-img{height:300px}
    .thumbs{ grid-template-columns:repeat(2,1fr); }
    .fullscreen-nav{ width:45px; height:45px; font-size:24px; }
    .fullscreen-nav.prev{left:15px}
    .fullscreen-nav.next{right:15px}
    /* Override fullscreen counter positioning on small screens.  Keep
       the counter at the top centre and remove additional padding.
       Use !important to ensure these values take precedence over
       earlier definitions. */
    .fullscreen-counter{
      top:20px !important;
      bottom:auto !important;
      padding:0 !important;
      font-size:14px !important;
    }

    .spec-input{ max-width:200px; }
  }

  /* Show navigation buttons in fullscreen mode on larger screens (e.g. desktop).
     These buttons replicate the non-fullscreen slider arrows and only appear
     when the viewport width is at least 768px. */
  @media(min-width:768px){
    .fullscreen-nav{
      display:flex;
      position:absolute;
      top:50%;
      transform:translateY(-50%);
      background:rgba(255,255,255,0.9);
      border:none;
      width:50px;
      height:50px;
      border-radius:50%;
      cursor:pointer;
      font-size:24px;
      align-items:center;
      justify-content:center;
      transition:all 0.3s ease;
      box-shadow:0 4px 12px rgba(0,0,0,0.15);
      z-index:2001;
    }
    .fullscreen-nav:hover{
      background:rgba(255,255,255,1);
      transform:translateY(-50%) scale(1.1);
    }
    .fullscreen-nav:active{
      transform:translateY(-50%) scale(0.95);
    }
    .fullscreen-nav.prev{ left:15px; }
    .fullscreen-nav.next{ right:15px; }
    [data-theme="dark"] .fullscreen-nav{
      background:rgba(255,255,255,0.15);
      color:#fff;
    }
    [data-theme="dark"] .fullscreen-nav:hover{
      background:rgba(255,255,255,0.25);
    }
  }

  /* Remove number input spinners (year, mileage, price) */
  input[type=number]::-webkit-inner-spin-button,
  input[type=number]::-webkit-outer-spin-button{
    -webkit-appearance: none;
    margin: 0;
  }
  input[type=number]{
    -moz-appearance: textfield; /* Firefox */
  }
  /* Center slider controls relative to the big photo only */
  .main-media{
    position:relative;
  }
</style>
</head>

<body>

<header>
  <div class="container header-inner">
    <a href="../index.html" class="logo">PAB SHOP</a>
    <nav>
      <a href="../index.html#home">Home</a>
      <a href="../index.html#cars">Cars</a>
      <a href="../index.html#contact">Contact</a>
    </nav>
    <button id="settingsToggle" class="settings-toggle">
      <span class="settings-icon">‚öôÔ∏è</span>
    </button>
  </div>
</header>

<!-- Settings Modal -->
<div class="settings-overlay" id="settingsOverlay">
  <div class="settings-modal">
    <div class="settings-header">
      <h2>Settings</h2>
      <button class="close-btn" id="closeSettings">√ó</button>
    </div>

    <div class="settings-section">
      <h3>Theme Mode</h3>
      <div class="theme-buttons">
        <button class="theme-btn" data-theme="light"><span>‚òÄÔ∏è</span><span>Light</span></button>
        <button class="theme-btn" data-theme="dark"><span>üåô</span><span>Dark</span></button>
      </div>
    </div>

    <!-- Owner login trigger -->
    <div class="settings-section" id="ownerLoginSection">
      <h3>Secret</h3>
      <button id="showOwnerLoginBtn" class="theme-btn" style="width:100%;">Secret</button>
    </div>

    <!-- Admin section -->
    <div class="settings-section" id="adminSection" style="display:none;">
      <h3>Admin</h3>

      <div id="authLoggedOut" style="display:none;">
        <input id="adminEmail" type="email" placeholder="Owner email"
          style="width:100%; padding:12px; border-radius:10px; border:1px solid var(--border); margin-bottom:10px;">
        <input id="adminPassword" type="password" placeholder="Password"
          style="width:100%; padding:12px; border-radius:10px; border:1px solid var(--border); margin-bottom:10px;">
        <button id="loginBtn" class="theme-btn" style="width:100%;">Login</button>
      </div>

      <div id="authLoggedIn" style="display:none;">
        <p id="adminEmailLabel" style="color:var(--muted); margin-bottom:12px;"></p>
        <button id="logoutBtn" class="theme-btn" style="width:100%;">Logout</button>

        <div style="margin-top:14px;">
          <button id="viewUserBtn" class="theme-btn view-btn-inactive" style="width:100%;">User view</button>
          <button id="viewAdminBtn" class="theme-btn view-btn-inactive" style="width:100%; margin-top:10px;">Admin view</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="container">
  <a href="../index.html#cars" class="back-link">‚Üê Back to all cars</a>

  <section class="car-detail">
    <div class="car-header">
      <!-- Title (display) -->
      <h1 id="carTitleText">Loading...</h1>

      <!-- Title (edit, hidden until Edit clicked) -->
      <input
        id="carTitleInput"
        class="car-header-input spec-input"
        data-key="title"
        type="text"
        value=""
        disabled
        style="display:none;"
      />

      <!-- Price (display) -->
      <div class="car-price" id="carPriceText">Loading...</div>

      <!-- Price (edit, hidden until Edit clicked) -->
      <input
        id="carPriceInput"
        class="car-header-input spec-input"
        data-key="price"
        type="number"
        value=""
        disabled
        style="display:none;"
      />

      <div class="car-meta">Loading...</div>

      <!-- Duplicate edit controls (same behavior) -->
      <div class="inline-edit-controls admin-only" id="topInlineEditControls" style="display:none;">
        <div class="inline-edit-row">
          <button id="topEditBtn" class="theme-btn admin-edit-btn" type="button">‚úèÔ∏è Edit fields</button>
          <button id="topSaveBtn" class="theme-btn admin-save-btn" type="button" style="display:none;">‚úÖ Save</button>
        </div>
        <div class="inline-status" id="topInlineStatus"></div>
      </div>
    </div>

    <div class="content-grid">
      <div class="gallery">
        <div class="main-media">
          <img id="mainImg" class="main-img"
            src="../assets/images/placeholder.png"
            alt="Main car image">

          <button class="slider-btn prev" onclick="changeSlide(-1)">‚Äπ</button>
          <button class="slider-btn next" onclick="changeSlide(1)">‚Ä∫</button>

          <div class="slider-dots" id="sliderDots"></div>
        </div>

        <!-- SAVED thumbs only -->
        <div class="thumbs" id="thumbs">
          <!-- populated dynamically -->
          <div class="thumb active" data-idx="0" data-img="../assets/images/placeholder.png">
            <img src="../assets/images/placeholder.png" alt="Photo 1">
            <div class="thumb-cover-badge">COVER</div>
          </div>
        </div>

        <!-- ADMIN only: divider + tools + pending previews (below saved thumbs) -->
        <div class="admin-divider admin-only" id="adminDivider" style="display:none;"></div>

        <div class="admin-only" id="adminUploadsArea" style="display:none;">
          <div class="thumbs admin-tools-row" id="adminToolsRow"></div>
          <div class="thumbs admin-pending-row" id="adminPendingRow"></div>
        </div>
      </div>

      <div class="sidebar">
        <!-- Specifications -->
        <div class="info-card" id="specCard">
          <h3>Specifications</h3>

          <div class="spec-list" id="specList">
            <div class="spec-item" data-key="year">
              <span class="spec-label"><i class="fas fa-calendar-alt spec-icon"></i>Year</span>
              <span class="spec-value" data-role="value">Loading...</span>
            </div>
            <div class="spec-item" data-key="make">
              <span class="spec-label"><i class="fas fa-car spec-icon"></i>Make</span>
              <span class="spec-value" data-role="value">Loading...</span>
            </div>
            <div class="spec-item" data-key="model">
              <span class="spec-label"><i class="fas fa-tag spec-icon"></i>Model</span>
              <span class="spec-value" data-role="value">Loading...</span>
            </div>
            <div class="spec-item" data-key="mileage">
              <span class="spec-label"><i class="fas fa-tachometer-alt spec-icon"></i>Mileage</span>
              <span class="spec-value" data-role="value">Loading...</span>
            </div>
            <div class="spec-item" data-key="engine">
              <span class="spec-label"><i class="fas fa-cogs spec-icon"></i>Engine</span>
              <span class="spec-value" data-role="value">Loading...</span>
            </div>
            <div class="spec-item" data-key="transmission">
              <span class="spec-label"><i class="fas fa-cog spec-icon"></i>Transmission</span>
              <span class="spec-value" data-role="value">Loading...</span>
            </div>
            <div class="spec-item" data-key="drivetrain">
              <span class="spec-label"><i class="fas fa-road spec-icon"></i>Drivetrain</span>
              <span class="spec-value" data-role="value">Loading...</span>
            </div>
            <div class="spec-item" data-key="exterior_color">
              <span class="spec-label"><i class="fas fa-palette spec-icon"></i>Exterior</span>
              <span class="spec-value" data-role="value">Loading...</span>
            </div>
            <div class="spec-item" data-key="interior_color">
              <span class="spec-label"><i class="fas fa-couch spec-icon"></i>Interior</span>
              <span class="spec-value" data-role="value">Loading...</span>
            </div>
            <div class="spec-item" data-key="vin">
              <span class="spec-label"><i class="fas fa-barcode spec-icon"></i>VIN</span>
              <span class="spec-value" data-role="value">Loading...</span>
            </div>
          </div>

          <!-- Admin-only inline edit controls RIGHT under Specifications -->
          <div class="inline-edit-controls admin-only" id="inlineEditControls" style="display:none;">
            <div class="inline-edit-row">
              <button id="inlineEditBtn" class="theme-btn admin-edit-btn" type="button">
                ‚úèÔ∏è Edit fields
              </button>
              <button id="inlineSaveBtn" class="theme-btn admin-save-btn" type="button" style="display:none;">
                ‚úÖ Save
              </button>
            </div>
            <div class="inline-status" id="inlineEditStatus"></div>
          </div>
        </div>

        <!-- ADMIN ONLY ACTIONS (below specifications) -->
        <div class="info-card admin-only" id="carAdminActions" style="display:none;">
          <h3>Admin Actions</h3>
          <div class="action-buttons">
            <button class="action-btn sold" id="toggleSoldBtn" type="button">Mark Sold</button>
            <button class="action-btn delete" id="deleteCarBtn" type="button">Delete</button>
          </div>
        </div>

      </div>
    </div>

    <div class="description" id="descriptionBox">
      <h2>About This Car</h2>

      <!-- DISPLAY (everyone sees this, preserves new lines) -->
      <p id="carDescription" style="white-space:pre-wrap;">Loading...</p>

      <!-- EDIT (admin only, swaps in-place, matches display typography, auto-expands) -->
      <textarea
        id="descEdit"
        class="desc-textarea admin-only"
        data-key="description"
        disabled
        style="
          display:none;
          width:100%;
          box-sizing:border-box;
          white-space:pre-wrap;
          overflow:hidden;
          resize:none;
          font: inherit;
          font-size: inherit;
          line-height: inherit;
          color: inherit;
          background: transparent;
          border: 1px solid var(--border);
          border-radius: 12px;
          padding: 0;
        "
        placeholder="Description..."
      ></textarea>

      <!-- Controls live here, but NO separate editor panel -->
      <div class="inline-edit-controls admin-only" id="aboutInlineEditControls" style="margin-top:14px; display:none;">
        <div class="inline-edit-row">
          <button id="aboutEditBtn" class="theme-btn admin-edit-btn" type="button">
            ‚úèÔ∏è Edit fields
          </button>
          <button id="aboutSaveBtn" class="theme-btn admin-save-btn" type="button" style="display:none;">
            ‚úÖ Save
          </button>
        </div>
        <div class="inline-status" id="aboutInlineStatus"></div>
      </div>
    </div>
  </section>

  <section id="contact" class="container">
    <h2>Contact Us</h2>
    <p>Contact us for more information</p>
    <div class="contact-buttons">
      <a href="tel:+15165657312" class="contact-btn">üìû Call: +1 (516) 565-7312</a>
      <a href="mailto:pabshopcars@gmail.com" class="contact-btn email">‚úâÔ∏è Email Us</a>
      <a href="tel:+15857347880" class="contact-btn secondary">üìû Call: +1 (585) 734-7880</a>
    </div>
  </section>
</div>

<!-- Fullscreen Image Viewer (USER VIEW) -->
<div class="fullscreen-overlay" id="fullscreenOverlay">
  <span class="fullscreen-close" id="fullscreenClose">√ó</span>
  <button class="fullscreen-nav prev" id="fullscreenPrev">‚Äπ</button>
  <button class="fullscreen-nav next" id="fullscreenNext">‚Ä∫</button>
  <div class="fullscreen-counter" id="fullscreenCounter">1 of 1</div>
  <img id="fullscreenImg" class="fullscreen-img" src="" alt="Fullscreen view">
</div>

<!-- Admin Photo Preview Modal (NOT fullscreen) -->
<div class="admin-photo-overlay admin-only" id="adminPhotoOverlay">
  <div class="admin-photo-modal">
    <button class="admin-photo-close" id="adminPhotoClose">√ó</button>

    <div class="admin-photo-wrap">
      <img id="adminPhotoImg" src="" alt="Preview">
      <div class="admin-cover-badge" id="adminCoverBadge">COVER</div>

      <button class="admin-photo-delete" id="adminDeleteBtn" title="Delete">üóë</button>
      <button class="admin-photo-cover" id="adminCoverBtn" title="Set as cover">Set as cover</button>
    </div>

    <p id="adminPhotoStatus" style="color:var(--muted); margin-top:12px;"></p>
  </div>
</div>

<!-- ====== Pretty confirm modal ====== -->
<div class="pab-confirm-overlay" id="pabConfirmOverlay" aria-hidden="true">
  <div class="pab-confirm-modal" role="dialog" aria-modal="true" aria-labelledby="pabConfirmTitle">
    <div class="pab-confirm-head">
      <div class="pab-confirm-title" id="pabConfirmTitle">
        <span class="pab-confirm-icon" id="pabConfirmIcon">?</span>
        <span id="pabConfirmTitleText">Confirm</span>
      </div>
      <button class="pab-confirm-close" id="pabConfirmClose" type="button" aria-label="Close">√ó</button>
    </div>
    <div class="pab-confirm-body" id="pabConfirmMsg">Are you sure?</div>
    <div class="pab-confirm-actions">
      <button class="pab-confirm-btn cancel" id="pabConfirmCancel" type="button">Cancel</button>
      <button class="pab-confirm-btn ok" id="pabConfirmOk" type="button">OK</button>
    </div>
  </div>
</div>
<!-- ====== end confirm modal ====== -->

<footer>
  <div class="container">
    <p>
      This website is a demo vehicle inventory and listing platform for a private auto business.
      No payments are processed and no sensitive personal information is collected.
    </p>
    <p>¬© 2025 PAB SHOP. All rights reserved.</p>
  </div>
</footer>

<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
  /**********************
   * Settings
   **********************/
  const root = document.documentElement;
  const settingsToggle = document.getElementById('settingsToggle');
  const settingsOverlay = document.getElementById('settingsOverlay');
  const closeSettings = document.getElementById('closeSettings');

  const savedTheme = localStorage.getItem('theme') || 'dark';
  root.setAttribute('data-theme', savedTheme);
  updateThemeButtons();

  settingsToggle.onclick = () => settingsOverlay.classList.add('active');
  closeSettings.onclick = () => settingsOverlay.classList.remove('active');
  settingsOverlay.onclick = (e) => { if (e.target === settingsOverlay) settingsOverlay.classList.remove('active'); };

  document.querySelectorAll('.theme-btn[data-theme]').forEach(btn => {
    btn.onclick = () => {
      const theme = btn.dataset.theme;
      if (!theme) return;
      root.setAttribute('data-theme', theme);
      localStorage.setItem('theme', theme);
      updateThemeButtons();
    };
  });

  function updateThemeButtons() {
    const currentTheme = root.getAttribute('data-theme');
    document.querySelectorAll('.theme-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.theme === currentTheme);
    });
  }
</script>

<script>
  /**********************
   * Supabase
   **********************/
  const SUPABASE_URL = "https://liipbpmjqjqxkuflufkv.supabase.co";
  const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxpaXBicG1qcWpxeGt1Zmx1Zmt2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU5MTg0MjYsImV4cCI6MjA4MTQ5NDQyNn0.LrIRgiVCE6E9vyXduQZEkdKAmmLDij2kQN2ajjavTS8";
  const db = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

  // ===== Image pipeline knobs (free-tier friendly) =====
  const PAB_IMAGE = {
    maxPhotosPerCar: 250,
    fullMaxDim: 1080,
    fullQuality: 0.82,
    noCompressBelowBytes: 100 * 1024,   // 100KB
    compressOnlyAboveBytes: 200 * 1024  // 200KB
  };

  window.isAdmin = false;
  function $(id){ return document.getElementById(id); }

  // ===== reliability helpers (avoid "works only after reload" nonsense) =====
  const ACTION_LOCKS = new Set();

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  function isRetryableError(err){
    const status = err?.status || err?.statusCode;
    if (typeof status === "number"){
      if ([400,401,403,404,409,413].includes(status)) return false;
      if (status >= 500 || status === 429) return true;
    }
    // If we don't know, assume it might be transient (network/CORS/timeouts).
    return true;
  }

  async function retryAsync(fn, retries = 2, baseDelay = 350){
    let lastErr;
    for (let attempt = 0; attempt <= retries; attempt++){
      try{
        return await fn(attempt);
      } catch (e){
        lastErr = e;
        if (attempt >= retries || !isRetryableError(e)) break;
        const jitter = Math.floor(Math.random() * 120);
        const delay = baseDelay * (2 ** attempt) + jitter;
        await sleep(delay);
      }
    }
    throw lastErr;
  }

  async function withActionLock(key, fn){
    if (ACTION_LOCKS.has(key)) return;
    ACTION_LOCKS.add(key);
    try{ return await fn(); }
    finally{ ACTION_LOCKS.delete(key); }
  }

  async function sb(op){
    const res = await op();
    if (res?.error) throw res.error;
    return res;
  }

  function formatNumber(val){
    if (val === null || val === undefined || val === "") return "";
    const n = Number(val);
    if (!Number.isFinite(n)) return String(val);
    return new Intl.NumberFormat("en-US").format(n);
  }


  function getViewMode(){ return localStorage.getItem("viewMode") || "admin"; }
  function setViewMode(mode){
    localStorage.setItem("viewMode", mode);
    location.reload();
  }
  function canSeeAdminNow(){
    return window.isAdmin && (getViewMode() !== "user");
  }

  function updateViewButtons(){
    const mode = getViewMode();
    const userBtn = $("viewUserBtn");
    const adminBtn = $("viewAdminBtn");
    if (!userBtn || !adminBtn) return;

    if (mode === "admin"){
      adminBtn.classList.add("view-btn-active");
      adminBtn.classList.remove("view-btn-inactive");
      userBtn.classList.add("view-btn-inactive");
      userBtn.classList.remove("view-btn-active");
    } else {
      userBtn.classList.add("view-btn-active");
      userBtn.classList.remove("view-btn-inactive");
      adminBtn.classList.add("view-btn-inactive");
      adminBtn.classList.remove("view-btn-active");
    }
  }

  function autoResizeTextarea(el){
    if (!el) return;
    el.style.height = "auto";
    el.style.height = (el.scrollHeight) + "px";
  }

  function syncDescTextareaToDisplay(){
    const descText = $("carDescription");
    const desc = $("descEdit");
    if (!descText || !desc) return;

    const cs = getComputedStyle(descText);
    desc.style.fontFamily = cs.fontFamily;
    desc.style.fontSize = cs.fontSize;
    desc.style.fontWeight = cs.fontWeight;
    desc.style.lineHeight = cs.lineHeight;
    desc.style.letterSpacing = cs.letterSpacing;
    desc.style.padding = cs.padding || "0";
    desc.style.margin = "0";
    desc.style.color = cs.color;

    if (!desc.style.padding || desc.style.padding === "0px") desc.style.padding = "0";
    autoResizeTextarea(desc);
  }

  function applyAdminView(){
    const adminEls = document.querySelectorAll(".admin-only");
    const canSee = canSeeAdminNow();
    adminEls.forEach(el => { el.style.display = canSee ? "" : "none"; });

    const editControls = $("inlineEditControls");
    if (editControls) editControls.style.display = canSee ? "" : "none";

    const adminBox = $("carAdminActions");
    if (adminBox) adminBox.style.display = canSee ? "" : "none";

    const topControls = $("topInlineEditControls");
    if (topControls) topControls.style.display = canSee ? "" : "none";

    const aboutControls = $("aboutInlineEditControls");
    if (aboutControls) aboutControls.style.display = canSee ? "" : "none";

    const desc = $("descEdit");
    if (desc && !INLINE_EDIT.editing) desc.style.display = "none";
  }

  async function refreshAuthUI(){
    const { data: { session } } = await db.auth.getSession();
    window.isAdmin = !!session;

    const adminSection = $("adminSection");
    const ownerLoginSection = $("ownerLoginSection");

    const outBox = $("authLoggedOut");
    const inBox  = $("authLoggedIn");
    const emailLabel = $("adminEmailLabel");

    if (window.isAdmin){
      if (adminSection) adminSection.style.display = "";
      if (ownerLoginSection) ownerLoginSection.style.display = "none";
    } else {
      if (adminSection) adminSection.style.display = "none";
      if (ownerLoginSection) ownerLoginSection.style.display = "";
    }

    if (outBox) outBox.style.display = window.isAdmin ? "none" : "";
    if (inBox)  inBox.style.display  = window.isAdmin ? "" : "none";

    if (emailLabel && session?.user?.email){
      emailLabel.textContent = `Logged in as: ${session.user.email}`;
    }

    applyAdminView();
    updateViewButtons();
  }

  async function loginOwner(){
    const email = $("adminEmail")?.value?.trim();
    const password = $("adminPassword")?.value;
    if (!email || !password) return alert("Enter email + password.");
    const { error } = await db.auth.signInWithPassword({ email, password });
    if (error){ console.error(error); return alert("Login failed."); }
    await refreshAuthUI();
    location.reload();
  }

  async function logoutOwner(){
    const { error } = await db.auth.signOut();
    if (error) console.error(error);
    await refreshAuthUI();
    location.reload();
  }

  /**********************
   * Pretty confirm modal helper
   **********************/
  const PAB_CONFIRM = {
    open: false,
    resolver: null,
    escHandler: null,

    show({ title="Confirm", message="Are you sure?", okText="OK", cancelText="Cancel", danger=false, icon="?" }){
      return new Promise((resolve) => {
        const overlay = $("pabConfirmOverlay");
        const titleText = $("pabConfirmTitleText");
        const msg = $("pabConfirmMsg");
        const okBtn = $("pabConfirmOk");
        const cancelBtn = $("pabConfirmCancel");
        const closeBtn = $("pabConfirmClose");
        const iconEl = $("pabConfirmIcon");
        if (!overlay || !titleText || !msg || !okBtn || !cancelBtn || !closeBtn || !iconEl){
          resolve(window.confirm(message));
          return;
        }

        this.open = true;
        this.resolver = resolve;

        titleText.textContent = title;
        msg.textContent = message;
        iconEl.textContent = icon;

        okBtn.textContent = okText;
        cancelBtn.textContent = cancelText;

        okBtn.classList.remove("danger","ok","warn");
        if (danger) {
          okBtn.classList.add("danger");
        } else if (icon === "‚ö†Ô∏è" || icon === "‚úÖ") {
          okBtn.classList.add("warn");
        } else {
          okBtn.classList.add("ok");
        }

        const finish = (val) => {
          if (!this.open) return;
          this.open = false;

          overlay.classList.remove("active");
          overlay.style.display = "none";
          overlay.setAttribute("aria-hidden", "true");

          okBtn.onclick = null;
          cancelBtn.onclick = null;
          closeBtn.onclick = null;

          if (this.escHandler){
            document.removeEventListener("keydown", this.escHandler);
            this.escHandler = null;
          }

          const r = this.resolver;
          this.resolver = null;
          if (typeof r === "function") r(val);
        };

        okBtn.onclick = () => finish(true);
        cancelBtn.onclick = () => finish(false);
        closeBtn.onclick = () => finish(false);

        overlay.onclick = (e) => {
          if (e.target === overlay) finish(false);
        };

        this.escHandler = (e) => {
          if (e.key === "Escape") finish(false);
        };
        document.addEventListener("keydown", this.escHandler);

        overlay.style.display = "flex";
        overlay.setAttribute("aria-hidden", "false");
        requestAnimationFrame(() => overlay.classList.add("active"));
        setTimeout(() => okBtn.focus(), 50);
      });
    }
  };

  /**********************
   * Storage helpers (WebP + full + thumb)
   **********************/
  function uniq(arr){
    return Array.from(new Set((arr || []).filter(Boolean)));
  }

  const STORAGE_BUCKET = 'cars';

  function isFullUrl(val){
    return typeof val === 'string' && (val.startsWith('http://') || val.startsWith('https://'));
  }

  function safeFolderName(raw, fallback){
    // Lowercase, trim, spaces->hyphens, remove unsafe, collapse hyphens, limit length
    let s = String(raw || '').trim().toLowerCase();
    // Replace separators/spaces with hyphen
    s = s.replace(/[\s_]+/g, '-');
    // Remove unsafe characters
    s = s.replace(/[\\/\?#!%&"'<>\[\]{}()*+:;=,@$^`|~]/g, '-');
    // Keep only a-z0-9 and hyphen
    s = s.replace(/[^a-z0-9-]+/g, '-');
    // Collapse multiple hyphens
    s = s.replace(/-+/g, '-').replace(/^-|-$/g, '');
    // Limit length
    if (s.length > 60) s = s.slice(0, 60).replace(/-+$/g, '');
    if (!s) s = String(fallback || 'unknown-car').trim().toLowerCase() || 'unknown-car';
    // Final safety
    s = s.replace(/[^a-z0-9-]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    return s || 'unknown-car';
  }

  function getCarDisplayTitle(car){
    const direct = (car && (car.title || car.name)) ? String(car.title || car.name).trim() : '';
    if (direct) return direct;
    const parts = [car?.year, car?.make, car?.model].map(v => String(v || '').trim()).filter(Boolean);
    return parts.join(' ').trim();
  }

  function getCarFolderPath(car){
    const base = getCarDisplayTitle(car);
    const folder = safeFolderName(base, car?.id || 'unknown-car');
    return `cars/${folder}`;
  }

  function toThumbUrl(fullUrl){
    if (!fullUrl || !isFullUrl(fullUrl)) return fullUrl;
    // Our convention: .../full/<file> -> .../thumb/<file>
    if (fullUrl.includes('/full/')) return fullUrl.replace('/full/', '/thumb/');
    return fullUrl;
  }

  function resolveImageRef(ref){
    if (!ref) return "";
    if (isFullUrl(ref)) return ref;
    // Treat non-URL strings as Supabase Storage paths within the bucket
    const path = String(ref).replace(/^\/+/, "");
    try{
      const { data } = db.storage.from(STORAGE_BUCKET).getPublicUrl(path);
      return data?.publicUrl || "";
    }catch(e){
      return "";
    }
  }

  function resolveThumbRef(ref){
    if (!ref) return "";
    if (isFullUrl(ref)) return toThumbUrl(ref);
    const path = String(ref).replace(/^\/+/, "");
    const thumbPath = path.includes('/full/') ? path.replace('/full/','/thumb/') : path;
    try{
      const { data } = db.storage.from(STORAGE_BUCKET).getPublicUrl(thumbPath);
      return data?.publicUrl || "";
    }catch(e){
      return "";
    }
  }

  async function deleteAllCarImagesFromStorage(car){
    // Only remove Supabase storage objects (skip Cloudinary public_ids)
    const urls = uniq([...(car.images || []), car.cover_image]);
    const paths = uniq(urls.map(urlToStoragePath).filter(Boolean));
    if (!paths.length) return;
    const { error } = await db.storage.from(STORAGE_BUCKET).remove(paths);
    if (error) throw error;
  }

  function sanitizeBaseName(name){
    const base = (name || 'photo').toLowerCase().replace(/\.[a-z0-9]+$/i, '');
    return base.replace(/[^a-z0-9_-]+/g, '_').replace(/_+/g, '_').slice(0, 40) || 'photo';
  }

  function urlToStoragePath(url){
    const marker = '/storage/v1/object/public/cars/';
    const idx = String(url || '').indexOf(marker);
    if (idx === -1) return null;
    return url.substring(idx + marker.length);
  }

  async function fileToImageBitmapSafe(file){
    if ('createImageBitmap' in window) {
      try { return await createImageBitmap(file); } catch(e) {}
    }
    const url = URL.createObjectURL(file);
    try{
      const img = await new Promise((resolve, reject) => {
        const i = new Image();
        i.onload = () => resolve(i);
        i.onerror = reject;
        i.src = url;
      });
      return img;
    } finally {
      try{ URL.revokeObjectURL(url); }catch(e){}
    }
  }

  async function canvasToWebPBlob(canvas, quality){
    return await new Promise((resolve) => {
      canvas.toBlob((b) => {
        if (b) return resolve(b);
        canvas.toBlob((j) => resolve(j), 'image/jpeg', Math.min(0.9, Math.max(0.6, quality || 0.8)));
      }, 'image/webp', quality);
    });
  }

  function drawCoverFit(ctx, src, targetW, targetH){
    const sw = src.width;
    const sh = src.height;
    const sAspect = sw / sh;
    const tAspect = targetW / targetH;
    let sx = 0, sy = 0, sww = sw, shh = sh;
    if (sAspect > tAspect){
      sww = Math.round(sh * tAspect);
      sx = Math.round((sw - sww) / 2);
    } else {
      shh = Math.round(sw / tAspect);
      sy = Math.round((sh - shh) / 2);
    }
    ctx.drawImage(src, sx, sy, sww, shh, 0, 0, targetW, targetH);
  }

  async function convertToWebP(file, maxDim, quality, cropThumb=false){
    const src = await fileToImageBitmapSafe(file);
    const sw = src.width; const sh = src.height;
    let tw = sw, th = sh;
    if (!cropThumb){
      const scale = Math.min(1, maxDim / Math.max(sw, sh));
      tw = Math.max(1, Math.round(sw * scale));
      th = Math.max(1, Math.round(sh * scale));
    } else {
      const scale = Math.min(1, maxDim / Math.max(sw, sh));
      const cw = Math.max(1, Math.round(sw * scale));
      const ch = Math.max(1, Math.round(sh * scale));
      if (cw / ch >= 1.5){ tw = cw; th = Math.max(1, Math.round(cw / 1.5)); } else { th = ch; tw = Math.max(1, Math.round(ch * 1.5)); }
    }
    const canvas = document.createElement('canvas');
    canvas.width = tw; canvas.height = th;
    const ctx = canvas.getContext('2d', { alpha: false });
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,tw,th);
    if (!cropThumb) ctx.drawImage(src, 0, 0, tw, th); else drawCoverFit(ctx, src, tw, th);
    const webpBlob = await canvasToWebPBlob(canvas, quality);
    try{ if (src && typeof src.close === 'function') src.close(); }catch(e){}
    return webpBlob;
  }

  async function uploadOneWebPToSupabase(carId, file, stamp){
    // Validate
    if (!file || !file.type || !file.type.startsWith('image/')){
      throw new Error('Only image files are allowed.');
    }

    // Decide whether to recompress/convert based on size
    async function compressBestEffort(file, {
      targetBytes = 200 * 1024,
      maxDim = 1080,
      startQuality = 0.82,
      minQuality = 0.65,
      step = 0.04
    } = {}){
      let q = startQuality;
      let bestBlob = null;
      while (q >= minQuality){
        const blob = await convertToWebP(file, maxDim, q, false);
        if (!bestBlob || blob.size < bestBlob.size) bestBlob = blob;
        if (blob.size <= targetBytes){
          return { blob, qualityUsed: q, hitTarget: true };
        }
        q -= step;
      }
      return { blob: bestBlob, qualityUsed: Math.max(minQuality, q + step), hitTarget: false };
    }

    async function maybeCompressFull(file){
      const kb = (file && file.size) ? (file.size / 1024) : 0;
      if (kb < 100) return file; // keep original
      if (kb <= 200){
        const blob = await convertToWebP(file, 1080, 0.82, false);
        return new File([blob], file.name.replace(/\.[\w]+$/, '.webp'), { type: 'image/webp' });
      }
      const result = await compressBestEffort(file, { targetBytes: 200 * 1024, maxDim: 1080 });
      const uploadFile = new File([result.blob], file.name.replace(/\.[\w]+$/, '.webp'), { type: 'image/webp' });
      if (!result.hitTarget) console.warn('Could not reach 200KB. Uploaded best effort:', uploadFile.size, 'bytes');
      return uploadFile;
    }

    const car = window.currentCar || { id: carId };
    const folder = getCarFolderPath(car);
    const base = sanitizeBaseName(file.name);
    const unique = `${Date.now()}_${stamp || 0}_${Math.random().toString(16).slice(2,8)}`;

    const fullFile = await maybeCompressFull(file);
    const fullBlob = fullFile instanceof File ? fullFile : new File([fullFile], `${base}.webp`, { type: 'image/webp' });
    const thumbBlob = await convertToWebP(file, 420, 0.86, true);

    const fullPath = `${folder}/full/${unique}_${base}.webp`;
    const thumbPath = `${folder}/thumb/${unique}_${base}.webp`;

    const upOpts = { contentType: 'image/webp', cacheControl: '3600', upsert: false };

    const { error: upFullErr } = await retryAsync(() => db.storage.from(STORAGE_BUCKET).upload(fullPath, fullBlob, upOpts), 2, 400);
    if (upFullErr) throw upFullErr;
    const { error: upThumbErr } = await retryAsync(() => db.storage.from(STORAGE_BUCKET).upload(thumbPath, thumbBlob, upOpts), 2, 400);
    if (upThumbErr) throw upThumbErr;

    const { data: fullData } = db.storage.from(STORAGE_BUCKET).getPublicUrl(fullPath);
    const { data: thumbData } = db.storage.from(STORAGE_BUCKET).getPublicUrl(thumbPath);

    return { fullUrl: fullData?.publicUrl || null, thumbUrl: thumbData?.publicUrl || null, fullPath, thumbPath };
  }

  async function uploadPhotosForCar(carId, files){
    // Backwards compatible: optional third arg `onProgress(done,total,lastResult)`
    const uploaded = [];
    const stamp = Date.now();
    for (let i = 0; i < files.length; i++){
      const up = await uploadOneWebPToSupabase(carId, files[i], stamp + i);
      uploaded.push(up);
      try{ const onProgress = arguments[2]; if (typeof onProgress === 'function') onProgress(i+1, files.length, up); }catch(e){}
    }
    return uploaded;
  }

  async function saveCarImages(carId, newItems){
    // Store Supabase public URLs in cars.images array
    const existing = Array.isArray(window.currentCar?.images) ? window.currentCar.images : [];
    const newUrls = newItems.map(p => p.fullUrl || p.url || p).filter(Boolean);
    const merged = [...existing, ...newUrls];
    const { error } = await retryAsync(() => db.from('cars').update({ images: merged }).eq('id', carId), 2, 350);
    if (error) throw error;
  }

  async function setCoverImage(carId, url){
    const { error } = await retryAsync(() => db.from('cars').update({ cover_image: url || null }).eq('id', carId), 2, 350);
    if (error) throw error;
  }

  async function deleteCarImage(carId, idOrUrl){
    // Do not call Cloudinary delete from client-side. Only delete Supabase storage paths when applicable.
    const storagePath = urlToStoragePath(idOrUrl);
    if (storagePath){
      const toRemove = [storagePath];
      if (storagePath.includes('/full/')) toRemove.push(storagePath.replace('/full/','/thumb/'));
      const { error: storageErr } = await db.storage.from(STORAGE_BUCKET).remove(toRemove);
      if (storageErr) throw storageErr;
    }
    const car = window.currentCar;
    const existing = Array.isArray(car?.images) ? car.images : [];
    const nextImages = existing.filter(x => x !== idOrUrl);
    const updatePayload = { images: nextImages };
    if (car?.cover_image === idOrUrl){ updatePayload.cover_image = nextImages[0] || null; }
    const { error: dbErr } = await db.from('cars').update(updatePayload).eq('id', carId);
    if (dbErr) throw dbErr;
  }

  /**********************
   * Admin photo modal actions
   **********************/
  function openAdminPhotoModal(url){
    if (!canSeeAdminNow()) return;
    const overlay = $("adminPhotoOverlay");
    const img = $("adminPhotoImg");
    const status = $("adminPhotoStatus");
    const badge = $("adminCoverBadge");
    const coverBtn = $("adminCoverBtn");
    if (!overlay || !img) return;

    const idOrUrl = url;
    // Supabase-only: we store and display public URLs
    img.src = resolveImageRef(idOrUrl);
    img.dataset.url = idOrUrl;
    overlay.style.display = "flex";
    if (status) status.textContent = "";

    const isCover = window.currentCar?.cover_image === idOrUrl;
    if (badge) badge.style.display = isCover ? "" : "none";
    if (coverBtn) coverBtn.textContent = isCover ? "Cover ‚úÖ" : "Set as cover";
  }

  function closeAdminPhotoModal(){
    const overlay = $("adminPhotoOverlay");
    const img = $("adminPhotoImg");
    const status = $("adminPhotoStatus");
    if (overlay) overlay.style.display = "none";
    if (img){ img.src = ""; img.dataset.url = ""; }
    if (status) status.textContent = "";
    document.dispatchEvent(new Event("adminModalClosed"));
  }

  function wireAdminModalButtons(){
    $("adminPhotoClose")?.addEventListener("click", closeAdminPhotoModal);
    $("adminPhotoOverlay")?.addEventListener("click", (e) => {
      if (e.target === $("adminPhotoOverlay")) closeAdminPhotoModal();
    });

    $("adminCoverBtn")?.addEventListener("click", async () => {
      return await withActionLock("setCover", async () => {
      if (!canSeeAdminNow()) return alert("Admin only.");
      const car = window.currentCar;
      const raw = $("adminPhotoImg")?.dataset?.url;
      const status = $("adminPhotoStatus");
      if (!car?.id || !raw) return;

      try{
        if (status) status.textContent = "Setting cover...";
        await setCoverImage(car.id, raw);
        // update in-memory model + UI without reload
        window.currentCar = window.currentCar || {};
        window.currentCar.cover_image = raw;
        if (status) status.textContent = "Cover updated.";
        const mainImg = $("mainImg"); if (mainImg) mainImg.src = resolveImageRef(raw);
        const badge = $("adminCoverBadge"); if (badge) badge.style.display = "";
        const coverBtnEl = $("adminCoverBtn"); if (coverBtnEl) coverBtnEl.textContent = "Cover ‚úÖ";
        PAB_GALLERY.updateCoverBadges();
      } catch(err){
        console.error(err);
        if (status) status.textContent = "Failed.";
        alert("Cover update failed. Check console.");
      }
      });
    });

    $("adminDeleteBtn")?.addEventListener("click", async () => {
      if (!canSeeAdminNow()) return alert("Admin only.");
      const car = window.currentCar;
      const url = $("adminPhotoImg")?.dataset?.url;
      const status = $("adminPhotoStatus");
      if (!car?.id || !url) return;

      const ok = await PAB_CONFIRM.show({
        title: "Delete photo",
        message: "Delete this photo? (no undo)",
        okText: "Delete",
        cancelText: "Cancel",
        danger: true,
        icon: "üóë"
      });
      if (!ok) return;

      try{
        if (status) status.textContent = "Deleting...";
        await deleteCarImage(car.id, url);
        // update in-memory model + UI without reload
        window.currentCar = window.currentCar || {};
        window.currentCar.images = Array.isArray(window.currentCar.images) ? window.currentCar.images.filter(x => x !== url) : [];
        if (window.currentCar.cover_image === url){ window.currentCar.cover_image = window.currentCar.images[0] || null; }
        if (status) status.textContent = "Deleted.";
        closeAdminPhotoModal();
        PAB_GALLERY.init(Array.isArray(window.currentCar.images) && window.currentCar.images.length ? window.currentCar.images : (window.currentCar.cover_image ? [window.currentCar.cover_image] : []));
        PAB_GALLERY.updateCoverBadges();
      } catch(err){
        console.error(err);
        if (status) status.textContent = "Failed.";
        alert("Delete failed. Check console.");
      }
    });
  }

  /**********************
   * Gallery controller (thumbs use derived thumb URLs)
   **********************/
  const PAB_GALLERY = {
    images: [],
    currentIndex: 0,
    pending: [],
    isWired: false,
    swipeGhost: null,
    swipeFlag: false,

    // Ghost image used for the fullscreen swipe animation.  It will be
    // created lazily when the user first initiates a fullscreen drag.
    fullscreenSwipeGhost: null,

    init(images){
      this.images = (images || []).filter(Boolean);
      this.currentIndex = 0;

      const mainImg = $("mainImg");
      const thumbsContainer = $("thumbs");
      const dotsContainer = $("sliderDots");
      if (!mainImg || !thumbsContainer || !dotsContainer) return;

      if (this.images.length === 0){
        mainImg.src = "";
        thumbsContainer.innerHTML = "";
        dotsContainer.innerHTML = "";
        this.injectAdminThumbTiles();
        this.renderPendingThumbs();
        return;
      }

      const prevBtn = document.querySelector(".slider-btn.prev");
      const nextBtn = document.querySelector(".slider-btn.next");
      const dotsBox = $("sliderDots");
      const showNav = this.images.length > 1;
      if (prevBtn) prevBtn.style.display = showNav ? "flex" : "none";
      if (nextBtn) nextBtn.style.display = showNav ? "flex" : "none";
      if (dotsBox) dotsBox.style.display = showNav ? "flex" : "none";

      const resolveDisplay = (ref) => resolveImageRef(ref);
      const resolveThumb = (ref) => resolveThumbRef(ref);

      mainImg.src = resolveDisplay(this.images[0]);

      thumbsContainer.innerHTML = this.images.map((idOrUrl, idx) => {
        const thumbUrl = resolveThumb(idOrUrl);
        const dataImg = idOrUrl; // keep identifier (public_id or full URL) in dataset
        return `
          <div class="thumb${idx===0 ? " active" : ""}" data-idx="${idx}" data-img="${dataImg}">
            <img src="${thumbUrl}" alt="Photo ${idx+1}" loading="lazy" decoding="async">
            <div class="thumb-cover-badge">COVER</div>
          </div>
        `;
      }).join("");

      // If a derived thumb doesn't load (legacy or missing), fail gracefully back to full.
      thumbsContainer.querySelectorAll("img").forEach(img => {
        img.addEventListener("error", () => {
          const parent = img.closest(".thumb");
          const idOrUrl = parent?.dataset?.img;
          if (!idOrUrl) return;
          const fallback = resolveImageRef(idOrUrl);
          if (fallback && img.src !== fallback) img.src = fallback;
        }, { once:true });
      });

      dotsContainer.innerHTML = this.images.map((_, idx) => `
        <div class="dot${idx===0 ? " active" : ""}" data-idx="${idx}"></div>
      `).join("");

      thumbsContainer.querySelectorAll(".thumb").forEach(el => {
        el.addEventListener("click", () => {
          const idx = parseInt(el.dataset.idx, 10);
          if (!Number.isFinite(idx)) return;
          this.goTo(idx);
        });
      });

      dotsContainer.querySelectorAll(".dot").forEach(el => {
        el.addEventListener("click", () => {
          const idx = parseInt(el.dataset.idx, 10);
          if (!Number.isFinite(idx)) return;
          this.goTo(idx);
        });
      });

      window.changeSlide = (dir) => {
        if (!this.images.length) return;
        let next = this.currentIndex + dir;
        if (next < 0) next = this.images.length - 1;
        if (next >= this.images.length) next = 0;
        this.goTo(next);
      };

      mainImg.onclick = () => {
        // If we just swiped, don't treat it like a tap-to-fullscreen.
        if (this.swipeFlag){ this.swipeFlag = false; return; }
        const idOrUrl = this.images[this.currentIndex];
        if (canSeeAdminNow()){
          openAdminPhotoModal(idOrUrl);
          return;
        }
        this.openFullscreen();
      };

      // Wire swipe/fullscreen once
      if (!this.isWired){
        this.ensureSwipeGhost();
        this.wireSwipe();
        this.wireFullscreen();
        this.isWired = true;
      } else {
        this.ensureSwipeGhost();
      }

      this.updateCoverBadges();
      this.injectAdminThumbTiles();
      this.renderPendingThumbs();

      // (wired above)
    },

    ensureSwipeGhost(){
      if (this.swipeGhost && document.body.contains(this.swipeGhost)) return;
      const mainImg = $("mainImg");
      if (!mainImg) return;
      const host = mainImg.parentElement;
      if (!host) return;

      // Insert a ghost image under the main image. During drag we translate both,
      // so you can see the next/prev image sliding in (like Marketplace).
      let ghost = document.getElementById("swipeGhost");
      if (!ghost){
        ghost = document.createElement("img");
        ghost.id = "swipeGhost";
        ghost.className = "main-img swipe-ghost";
        ghost.alt = "";
        host.insertBefore(ghost, mainImg);
      }
      ghost.style.opacity = "0";
      ghost.style.transform = "translateX(0px)";
      this.swipeGhost = ghost;
    },

    wireSwipe(){
      const mainImg = $("mainImg");
      const ghost = () => this.swipeGhost;
      if (!mainImg) return;

      let dragging = false;
      let startX = 0;
      let lastX = 0;
      let activePointerId = null;

      const resolveDisplay = (ref) => resolveImageRef(ref);

      const setGhostForDir = (dir) => {
        const g = ghost();
        if (!g) return;
        if (!this.images.length) return;
        let idx = this.currentIndex + dir;
        if (idx < 0) idx = this.images.length - 1;
        if (idx >= this.images.length) idx = 0;

        g.src = resolveDisplay(this.images[idx]);
        g.style.opacity = "1";
        // Use the width of the container rather than the image itself.  When
        // images have different aspect ratios their rendered widths can
        // change between slides.  Using the parent container width
        // produces a consistent slide distance and eliminates the jumpy
        // resizing effect.
        const w = (mainImg.parentElement?.getBoundingClientRect().width || mainImg.getBoundingClientRect().width || 1);
        // place it just off-screen in the direction we're swiping from
        g.style.transform = `translateX(${dir > 0 ? w : -w}px)`;
      };

      const clearTransforms = () => {
        const g = ghost();
        mainImg.classList.remove("swipe-anim");
        g?.classList.remove("swipe-anim");
        mainImg.style.transform = "translateX(0px)";
        if (g){
          g.style.transform = "translateX(0px)";
          g.style.opacity = "0";
        }
      };

      const animateTo = (mainX, ghostX, done) => {
        const g = ghost();
        mainImg.classList.add("swipe-anim");
        g?.classList.add("swipe-anim");

        const onEnd = (e) => {
          if (e.target !== mainImg) return;
          mainImg.removeEventListener("transitionend", onEnd);
          mainImg.classList.remove("swipe-anim");
          g?.classList.remove("swipe-anim");
          if (typeof done === "function") done();
        };
        mainImg.addEventListener("transitionend", onEnd);

        mainImg.style.transform = `translateX(${mainX}px)`;
        if (g) g.style.transform = `translateX(${ghostX}px)`;
      };

      const onDown = (e) => {
        if (!this.images || this.images.length <= 1) return;
        // Only left-click for mouse
        if (e.pointerType === "mouse" && e.button !== 0) return;
        dragging = true;
        activePointerId = e.pointerId;
        startX = e.clientX;
        lastX = e.clientX;
        mainImg.setPointerCapture?.(activePointerId);
      };

      const onMove = (e) => {
        if (!dragging) return;
        if (activePointerId !== null && e.pointerId !== activePointerId) return;

        const dx = e.clientX - startX;
        lastX = e.clientX;

        // Small jitter? ignore.
        if (Math.abs(dx) < 3) return;

        // Determine direction once and prep ghost image.
        const dir = dx < 0 ? 1 : -1; // swipe left -> next (dir=+1)
        setGhostForDir(dir);

        const w = (mainImg.parentElement?.getBoundingClientRect().width || mainImg.getBoundingClientRect().width || 1);
        const g = ghost();

        // Move main with finger, pull ghost in from side.
        mainImg.style.transform = `translateX(${dx}px)`;
        if (g){
          const base = dir > 0 ? w : -w;
          g.style.transform = `translateX(${base + dx}px)`;
        }

        // If you moved enough, treat as swipe (prevents click-to-open)
        this.swipeFlag = true;
      };

      const onUp = () => {
        if (!dragging) return;
        dragging = false;
        const dx = lastX - startX;
        const w = (mainImg.parentElement?.getBoundingClientRect().width || mainImg.getBoundingClientRect().width || 1);
        const threshold = Math.min(120, w * 0.22);

        if (Math.abs(dx) >= threshold){
          const dir = dx < 0 ? 1 : -1;
          // Finish slide
          animateTo(dir > 0 ? -w : w, 0, () => {
            // Commit index change, reset transforms, and swap main image
            let next = this.currentIndex + dir;
            if (next < 0) next = this.images.length - 1;
            if (next >= this.images.length) next = 0;
            this.currentIndex = next;
            mainImg.style.transform = "translateX(0px)";
            mainImg.src = resolveDisplay(this.images[this.currentIndex]);
            const g = ghost();
            if (g){ g.style.opacity = "0"; g.style.transform = "translateX(0px)"; }
            this.updateActiveThumbs();
            this.preloadNeighbors();
          });
        } else {
          // Snap back
          animateTo(0, (dx < 0 ? w : -w), () => {
            clearTransforms();
          });
        }

        // release pointer capture
        try{ if (activePointerId !== null) mainImg.releasePointerCapture?.(activePointerId); }catch(e){}
        activePointerId = null;
      };

      mainImg.addEventListener("pointerdown", onDown);
      mainImg.addEventListener("pointermove", onMove);
      mainImg.addEventListener("pointerup", onUp);
      mainImg.addEventListener("pointercancel", onUp);
      mainImg.addEventListener("lostpointercapture", onUp);
    },

    /**
     * Attach swipe gestures to the fullscreen overlay.  This reuses
     * much of the logic from wireSwipe() but operates on the
     * fullscreen image and its overlay container.  Pointer events are
     * used to support both mouse and touch; dragging left or right
     * slides the current image away and brings in the next/previous
     * image with an animation.  If the drag is too small, the image
     * snaps back.  A ghost image is inserted behind the fullscreen
     * image during the drag so you can see the next photo sliding in.
     */
    wireFullscreenSwipe(){
      const fullImg = $("fullscreenImg");
      const overlay = $("fullscreenOverlay");
      if (!fullImg || !overlay) return;

      // Ensure ghost element exists inside overlay
      const ensureGhost = () => {
        if (this.fullscreenSwipeGhost && document.body.contains(this.fullscreenSwipeGhost)) return;
        const ghostId = "fullscreenSwipeGhost";
        let ghost = document.getElementById(ghostId);
        if (!ghost){
          ghost = document.createElement("img");
          ghost.id = ghostId;
          // Only assign the swipe-ghost class.  The fullscreen-img class
          // constrains the size (max-width/max-height) which we override
          // manually.  Leaving it off avoids conflicting styles.
          ghost.className = "swipe-ghost";
          ghost.alt = "";
          ghost.style.position = "absolute";
          ghost.style.top = "0";
          ghost.style.left = "0";
          ghost.style.width = "100%";
          ghost.style.height = "100%";
          ghost.style.objectFit = "contain";
          // Insert behind the fullscreen image
          overlay.insertBefore(ghost, fullImg);
        }
        ghost.style.opacity = "0";
        ghost.style.transform = "translateX(0px)";
        this.fullscreenSwipeGhost = ghost;
      };

      ensureGhost();

      // Drag state for single-finger swipes
      let dragging = false;
      let startX = 0;
      let lastX = 0;
      let activePointerId = null;
      let translateX = 0;
      // Map of active pointers for pinch-zoom.  Keys are pointerId and
      // values are {x,y}.  When two pointers are present, we interpret
      // the movement as a pinch and scale the image accordingly.
      const pointers = new Map();
      let pinchActive = false;
      let pinchStartDist = 0;
      let pinchStartScale = 1;
      let currentScale = 1;

      const resolveDisplay = (ref) => resolveImageRef(ref);
      const ghost = () => this.fullscreenSwipeGhost;

      const setGhostForDir = (dir) => {
        const g = ghost();
        if (!g) return;
        if (!this.images.length) return;
        let idx = this.currentIndex + dir;
        if (idx < 0) idx = this.images.length - 1;
        if (idx >= this.images.length) idx = 0;
        g.src = resolveDisplay(this.images[idx]);
        g.style.opacity = "1";
        const w = overlay.getBoundingClientRect().width || 1;
        g.style.transform = `translateX(${dir > 0 ? w : -w}px)`;
      };

      const clearTransforms = () => {
        const g = ghost();
        fullImg.classList.remove("swipe-anim");
        g?.classList.remove("swipe-anim");
        translateX = 0;
        currentScale = 1;
        fullImg.style.transform = "translateX(0px) scale(1)";
        if (g){
          g.style.transform = "translateX(0px)";
          g.style.opacity = "0";
        }
      };

      const animateTo = (mainX, ghostX, done) => {
        const g = ghost();
        fullImg.classList.add("swipe-anim");
        g?.classList.add("swipe-anim");
        const onEnd = (e) => {
          if (e.target !== fullImg) return;
          fullImg.removeEventListener("transitionend", onEnd);
          fullImg.classList.remove("swipe-anim");
          g?.classList.remove("swipe-anim");
          if (typeof done === "function") done();
        };
        fullImg.addEventListener("transitionend", onEnd);
        // When animating, preserve the current scale factor while
        // translating horizontally.  Ghost stays unscaled.
        translateX = mainX;
        fullImg.style.transform = `translateX(${mainX}px) scale(${currentScale})`;
        if (g) g.style.transform = `translateX(${ghostX}px)`;
      };

      const getDistance = (p1, p2) => {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return Math.hypot(dx, dy);
      };

      const applyTransform = () => {
        // Apply both translation and scaling to the fullscreen image.
        fullImg.style.transform = `translateX(${translateX}px) scale(${currentScale})`;
      };

      const onDown = (e) => {
        // Track all pointers for pinch detection
        pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        // If two pointers are down, start pinch mode
        if (pointers.size === 2){
          pinchActive = true;
          // compute initial distance between two pointers
          const [p1, p2] = Array.from(pointers.values());
          pinchStartDist = getDistance(p1, p2);
          pinchStartScale = currentScale;
          // cancel any ongoing drag
          dragging = false;
          activePointerId = null;
          return;
        }
        // Only consider single-pointer drags when pinch is not active
        if (pointers.size === 1 && !pinchActive){
          if (!this.images || this.images.length <= 1) return;
          if (e.pointerType === "mouse" && e.button !== 0) return;
          dragging = true;
          activePointerId = e.pointerId;
          startX = e.clientX;
          lastX = e.clientX;
          overlay.setPointerCapture?.(activePointerId);
        }
      };

      const onMove = (e) => {
        // Update tracked pointer positions
        if (pointers.has(e.pointerId)){
          pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        }
        // Handle pinch scaling when two pointers are present
        if (pinchActive && pointers.size >= 2){
          const [p1, p2] = Array.from(pointers.values());
          const dist = getDistance(p1, p2);
          if (pinchStartDist > 0){
            let scaleFactor = dist / pinchStartDist;
            // Clamp scaling between 1x and 4x
            currentScale = Math.min(Math.max(pinchStartScale * scaleFactor, 1), 4);
            applyTransform();
          }
          return;
        }
        // If not pinching, handle drag for single-pointer swipes
        if (!dragging) return;
        if (activePointerId !== null && e.pointerId !== activePointerId) return;
        const dx = e.clientX - startX;
        lastX = e.clientX;
        if (Math.abs(dx) < 3) return;
        const dir = dx < 0 ? 1 : -1;
        setGhostForDir(dir);
        const w = overlay.getBoundingClientRect().width || 1;
        const g = ghost();
        translateX = dx;
        applyTransform();
        if (g){
          const base = dir > 0 ? w : -w;
          g.style.transform = `translateX(${base + dx}px)`;
        }
        // mark that we swiped; prevents click-to-close from firing
        this.swipeFlag = true;
      };

      const onUp = (e) => {
        // Remove pointer from tracking map
        if (pointers.has(e.pointerId)) pointers.delete(e.pointerId);
        // If we were pinching, end pinch mode when fewer than two pointers remain
        if (pinchActive){
          if (pointers.size < 2){
            pinchActive = false;
            // Snap back to minimum scale if user pinched down
            if (currentScale <= 1){
              currentScale = 1;
              applyTransform();
            }
          }
          return;
        }
        if (!dragging) return;
        dragging = false;
        const dx = lastX - startX;
        const w = overlay.getBoundingClientRect().width || 1;
        // Use an even smaller threshold so the user doesn't need to drag as far
        // to change slides.  The distance is either 10% of the viewport
        // width or at most 80px.
        const threshold = Math.min(80, w * 0.10);
        // If the pointer was cancelled or lost, treat this as a cancellation
        // and snap the image back instead of sliding to the next/prev.
        const cancelled = e && e.type && e.type !== 'pointerup';
        if (!cancelled && Math.abs(dx) >= threshold){
          const dir = dx < 0 ? 1 : -1;
          animateTo(dir > 0 ? -w : w, 0, () => {
            let next = this.currentIndex + dir;
            if (next < 0) next = this.images.length - 1;
            if (next >= this.images.length) next = 0;
            this.currentIndex = next;
            translateX = 0;
            fullImg.style.transform = `translateX(0px) scale(${currentScale})`;
            fullImg.src = resolveDisplay(this.images[this.currentIndex]);
            // Update the slide counter text after changing images
            const counterEl = $("fullscreenCounter");
            if (counterEl) counterEl.textContent = `${this.currentIndex + 1} of ${this.images.length}`;
            const g = ghost();
            if (g){ g.style.opacity = "0"; g.style.transform = "translateX(0px)"; }
            this.updateActiveThumbs?.();
            this.preloadNeighbors?.();
          });
        } else {
          animateTo(0, (dx < 0 ? w : -w), () => {
            clearTransforms();
          });
        }
        try{ if (activePointerId !== null) overlay.releasePointerCapture?.(activePointerId); }catch(err){}
        activePointerId = null;
      };

      overlay.addEventListener("pointerdown", onDown);
      overlay.addEventListener("pointermove", onMove);
      overlay.addEventListener("pointerup", onUp);
      // When the pointer is cancelled (e.g. due to the device generating a
      // scroll or context menu), treat it as a cancelled gesture.  Passing
      // the event to onUp() ensures the drag snaps back without
      // transitioning slides.
      overlay.addEventListener("pointercancel", onUp);
      overlay.addEventListener("lostpointercapture", onUp);

      // Also support pinch zoom on touch devices using touch events.  Some
      // browsers may not fully support pointer events for multi-touch
      // gestures; these handlers ensure zoom works reliably.  They
      // operate on the same `currentScale` and `pinchActive` state as
      // pointer-based handling above.
      const getTouchDistance = (t1, t2) => {
        const dx = t2.clientX - t1.clientX;
        const dy = t2.clientY - t1.clientY;
        return Math.hypot(dx, dy);
      };
      fullImg.addEventListener('touchstart', (ev) => {
        if (ev.touches.length === 2){
          pinchActive = true;
          pinchStartDist = getTouchDistance(ev.touches[0], ev.touches[1]);
          pinchStartScale = currentScale;
        }
      }, { passive: false });
      fullImg.addEventListener('touchmove', (ev) => {
        if (pinchActive && ev.touches.length === 2){
          const dist = getTouchDistance(ev.touches[0], ev.touches[1]);
          if (pinchStartDist > 0){
            let scaleFactor = dist / pinchStartDist;
            currentScale = Math.min(Math.max(pinchStartScale * scaleFactor, 1), 4);
            applyTransform();
          }
          ev.preventDefault();
        }
      }, { passive: false });
      fullImg.addEventListener('touchend', (ev) => {
        if (ev.touches.length < 2){
          pinchActive = false;
          if (currentScale <= 1){
            currentScale = 1;
            applyTransform();
          }
        }
      });
    },

    updateActiveThumbs(){
      const thumbsContainer = $("thumbs");
      const dotsContainer = $("sliderDots");
      thumbsContainer?.querySelectorAll(".thumb").forEach(t => {
        const idx = parseInt(t.dataset.idx, 10);
        t.classList.toggle("active", idx === this.currentIndex);
      });
      dotsContainer?.querySelectorAll(".dot").forEach(d => {
        const idx = parseInt(d.dataset.idx, 10);
        d.classList.toggle("active", idx === this.currentIndex);
      });
    },

    preloadNeighbors(){
      // Preload the 2 closest neighbors (prev + next) so swipe feels instant.
      if (!Array.isArray(this.images) || this.images.length <= 1) return;

      const resolveDisplay = (ref) => resolveImageRef(ref);
      const total = this.images.length;

      const toPreload = new Set();
      for (let offset = 1; offset <= 1; offset++){
        toPreload.add((this.currentIndex - offset + total) % total);
        toPreload.add((this.currentIndex + offset) % total);
      }

      toPreload.forEach((idx) => {
        const url = resolveDisplay(this.images[idx]);
        if (!url) return;
        const img = new Image();
        img.decoding = "async";
        img.loading = "eager";
        img.src = url;
      });
    },

    goTo(idx){
      this.currentIndex = idx;
      const mainImg = $("mainImg");
      if (mainImg) mainImg.src = resolveImageRef(this.images[idx]);

      this.updateActiveThumbs();
      this.preloadNeighbors();
    },

    openFullscreen(){
      const overlay = $("fullscreenOverlay");
      const fullImg = $("fullscreenImg");
      const counter = $("fullscreenCounter");
      if (!overlay || !fullImg || !counter) return;
      fullImg.src = resolveImageRef(this.images[this.currentIndex]);
      // Use "of" instead of a slash for the slide count, matching the
      // reference video's counter style.
      counter.textContent = `${this.currentIndex + 1} of ${this.images.length}`;
      overlay.classList.add("active");
      // Prevent the underlying page from scrolling or receiving touch
      // events while the fullscreen viewer is open.  Without this,
      // users can scroll the page behind the overlay or interact
      // inadvertently with other elements.  Restored on close in
      // wireFullscreen().
      document.body.style.overflow = 'hidden';
    },

    wireFullscreen(){
      const overlay = $("fullscreenOverlay");
      const fullImg = $("fullscreenImg");
      const counter = $("fullscreenCounter");
      const close = $("fullscreenClose");
      const prev = $("fullscreenPrev");
      const next = $("fullscreenNext");

      close?.addEventListener("click", (e) => {
        e.stopPropagation();
        overlay?.classList.remove("active");
        // Restore scrolling when leaving fullscreen
        document.body.style.overflow = '';
      });

      overlay?.addEventListener("click", (e) => {
        if (e.target === overlay) overlay.classList.remove("active");
        // Restore scrolling when overlay closes
        if (!overlay.classList.contains('active')) document.body.style.overflow = '';
      });

      prev?.addEventListener("click", (e) => {
        e.stopPropagation();
        window.changeSlide(-1);
        if (fullImg) fullImg.src = resolveImageRef(this.images[this.currentIndex]);
        if (counter) counter.textContent = `${this.currentIndex + 1} of ${this.images.length}`;
      });

      // Prevent pointerdown events on the navigation buttons from propagating
      // to the overlay.  Without this the overlay's pointer handlers may
      // interpret the interaction as a swipe or click-to-close, causing
      // fullscreen mode to exit unexpectedly when clicking the buttons.
      prev?.addEventListener('pointerdown', (e) => { e.stopPropagation(); });
      next?.addEventListener('pointerdown', (e) => { e.stopPropagation(); });

      next?.addEventListener("click", (e) => {
        e.stopPropagation();
        window.changeSlide(1);
        if (fullImg) fullImg.src = resolveImageRef(this.images[this.currentIndex]);
        if (counter) counter.textContent = `${this.currentIndex + 1} of ${this.images.length}`;
      });

      document.addEventListener("keydown", (e) => {
        if (!overlay?.classList.contains("active")) return;
        if (e.key === "ArrowLeft"){
          window.changeSlide(-1);
          if (fullImg) fullImg.src = resolveImageRef(this.images[this.currentIndex]);
          if (counter) counter.textContent = `${this.currentIndex + 1} of ${this.images.length}`;
        }
        if (e.key === "ArrowRight"){
          window.changeSlide(1);
          if (fullImg) fullImg.src = resolveImageRef(this.images[this.currentIndex]);
          if (counter) counter.textContent = `${this.currentIndex + 1} of ${this.images.length}`;
        }
        if (e.key === "Escape"){
          overlay.classList.remove("active");
          document.body.style.overflow = '';
        }
      });


      // Enable pointer-based swipe in fullscreen overlay.  This will
      // attach pointer event listeners to the overlay to handle drag
      // gestures for sliding between images.  Without this call the
      // fullscreen slider would not support swiping.
      this.wireFullscreenSwipe();
    },

    updateCoverBadges(){
      const car = window.currentCar;
      const cover = car?.cover_image;
      document.querySelectorAll("#thumbs .thumb").forEach(el => {
        const url = el.dataset.img;
        const badge = el.querySelector(".thumb-cover-badge");
        if (!badge) return;

        if (canSeeAdminNow() && cover && url === cover){
          badge.style.display = "";
        } else {
          badge.style.display = "none";
        }
      });
    },

    injectAdminThumbTiles(){
      const toolsRow = $("adminToolsRow");
      const divider = $("adminDivider");
      const area = $("adminUploadsArea");
      if (!toolsRow || !divider || !area) return;

      toolsRow.innerHTML = "";

      if (!canSeeAdminNow()){
        divider.style.display = "none";
        area.style.display = "none";
        return;
      }

      divider.style.display = "";
      area.style.display = "";

      let input = $("adminThumbUploadInput");
      if (!input){
        input = document.createElement("input");
        input.type = "file";
        input.accept = "image/*";
        input.multiple = true;
        input.id = "adminThumbUploadInput";
        input.style.display = "none";
        document.body.appendChild(input);

        input.addEventListener("change", () => {
          const files = input.files ? Array.from(input.files) : [];
          if (!files.length) return;

          // Enforce max photos per car at selection time too
          const existingCount = Array.isArray(window.currentCar?.images) ? window.currentCar.images.length : 0;
          const remaining = Math.max(0, PAB_IMAGE.maxPhotosPerCar - existingCount);
          if (remaining <= 0){
            alert(`Max ${PAB_IMAGE.maxPhotosPerCar} photos per car reached.`);
            input.value = "";
            return;
          }

          const picked = files.slice(0, remaining);
          if (picked.length < files.length){
            alert(`Only ${remaining} more photos allowed for this car (limit ${PAB_IMAGE.maxPhotosPerCar}).`);
          }

          for (const f of picked){
            const url = URL.createObjectURL(f);
            this.pending.push({ file: f, url });
          }
          input.value = "";
          this.renderPendingThumbs();
        });
      }

      const uploadTile = document.createElement("div");
      uploadTile.className = "admin-upload-tile admin-only";
      uploadTile.innerHTML = `<div class="icon">üñº</div><div class="label">Upload</div>`;
      uploadTile.title = "Select photos (not saved yet)";
      uploadTile.addEventListener("click", () => {
        if (!canSeeAdminNow()) return alert("Admin only.");
        input.click();
      });

      const commitTile = document.createElement("div");
      commitTile.className = "admin-commit-tile admin-only";
      commitTile.innerHTML = `<div class="icon">‚¨Ü</div><div class="label">Save 0</div>`;
      commitTile.title = "Uploads WebP thumbs + WebP full size (free-tier friendly)";
      commitTile.style.display = "none";

      commitTile.addEventListener("click", async () => {
        return await withActionLock("uploadPhotos", async () => {
        if (!canSeeAdminNow()) return alert("Admin only.");
        const car = window.currentCar;
        if (!car?.id) return alert("Car not loaded yet.");
        if (!this.pending.length) return;

        // final max cap safety
        const existingCount = Array.isArray(car.images) ? car.images.length : 0;
        const remaining = Math.max(0, PAB_IMAGE.maxPhotosPerCar - existingCount);
        if (remaining <= 0) {
          alert(`Max ${PAB_IMAGE.maxPhotosPerCar} photos per car reached.`);
          return;
        }
        if (this.pending.length > remaining){
          alert(`Only ${remaining} more photos allowed for this car (limit ${PAB_IMAGE.maxPhotosPerCar}).`);
          this.pending = this.pending.slice(0, remaining);
          this.renderPendingThumbs();
          if (!this.pending.length) return;
        }

        commitTile.style.pointerEvents = "none";
        commitTile.style.opacity = "0.75";
        commitTile.querySelector(".label").textContent = "Uploading...";

        try{
          const files = this.pending.map(p => p.file);

          // prepare progress UI
          const labelEl = commitTile.querySelector('.label');
          const iconEl = commitTile.querySelector('.icon');
          if (labelEl) labelEl.textContent = `Uploading...`;
          if (iconEl) iconEl.textContent = "0%";

          // Upload each photo to Cloudinary (single upload per photo) with progress callback
          const results = await uploadPhotosForCar(car.id, files, (done, total) => {
            const pct = Math.round((done / total) * 100);
            if (iconEl) iconEl.textContent = `${pct}%`;
          });

          // Persist public_ids into DB
          await saveCarImages(car.id, results);

          // set cover if missing (use publicId when available, otherwise secureUrl)
          const first = results[0];
          const firstId = first ? (first.publicId || first.secureUrl) : null;
          if (!car.cover_image && firstId){
            await setCoverImage(car.id, firstId);
          }

          // update in-memory car images and re-render gallery instead of reloading
          const added = results.map(p => p.publicId || p.secureUrl).filter(Boolean);
          window.currentCar = window.currentCar || {};
          window.currentCar.images = Array.isArray(window.currentCar.images) ? [...window.currentCar.images, ...added] : added;
          if (!window.currentCar.cover_image && added[0]){
            window.currentCar.cover_image = added[0];
            try{ await setCoverImage(car.id, added[0]); }catch(e){ console.warn('setCoverImage failed', e); }
          }

          this.pending.forEach(p => { try{ URL.revokeObjectURL(p.url); }catch(e){} });
          this.pending = [];
          PAB_GALLERY.init(Array.isArray(window.currentCar.images) && window.currentCar.images.length ? window.currentCar.images : (window.currentCar.cover_image ? [window.currentCar.cover_image] : []));
          PAB_GALLERY.updateCoverBadges();
          this.updateCommitTile();
          // AUTO RELOAD AFTER SUCCESSFUL UPLOAD
          location.reload();
        } catch(err){
          console.error(err);
          alert("Upload failed. Check console.");
          commitTile.style.pointerEvents = "";
          commitTile.style.opacity = "";
          this.renderPendingThumbs();
        }
        });
      });

      toolsRow.appendChild(uploadTile);
      toolsRow.appendChild(commitTile);

      this.updateCommitTile();
    },

    updateCommitTile(){
      const commitTile = document.querySelector("#adminToolsRow .admin-commit-tile");
      if (!commitTile) return;

      if (!canSeeAdminNow() || !this.pending.length){
        commitTile.style.display = "none";
        return;
      }
      commitTile.style.display = "";
      commitTile.querySelector(".label").textContent = `Save ${this.pending.length}`;
      const iconEl = commitTile.querySelector('.icon'); if (iconEl) iconEl.textContent = '‚¨Ü';
      commitTile.style.pointerEvents = "";
      commitTile.style.opacity = "";
    },

    renderPendingThumbs(){
      const pendingRow = $("adminPendingRow");
      const divider = $("adminDivider");
      const area = $("adminUploadsArea");
      if (!pendingRow || !divider || !area) return;

      pendingRow.innerHTML = "";

      if (!canSeeAdminNow()){
        divider.style.display = "none";
        area.style.display = "none";
        this.updateCommitTile();
        return;
      }

      divider.style.display = "";
      area.style.display = "";

      for (let i = 0; i < this.pending.length; i++){
        const p = this.pending[i];

        const el = document.createElement("div");
        el.className = "thumb pending admin-only";
        el.dataset.pendingIdx = String(i);
        el.innerHTML = `
          <img src="${p.url}" alt="Pending ${i+1}">
          <button class="thumb-remove" title="Remove">√ó</button>
        `;

        const btn = el.querySelector(".thumb-remove");
        if (btn){
          btn.style.display = "";
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const idx = parseInt(el.dataset.pendingIdx, 10);
            if (!Number.isFinite(idx)) return;

            const removed = this.pending.splice(idx, 1)[0];
            if (removed?.url){
              try{ URL.revokeObjectURL(removed.url); }catch(e){}
            }
            this.renderPendingThumbs();
          });
        }

        el.addEventListener("click", () => {
          if (!canSeeAdminNow()) return;
          openAdminPhotoModal(p.url);
          const status = $("adminPhotoStatus");
          if (status) status.textContent = "Not uploaded yet. Saving will upload WebP thumb + WebP full.";

          $("adminCoverBtn").disabled = true;
          $("adminDeleteBtn").disabled = true;

          const onCloseReset = () => {
            $("adminCoverBtn").disabled = false;
            $("adminDeleteBtn").disabled = false;
            document.removeEventListener("adminModalClosed", onCloseReset);
          };
          document.addEventListener("adminModalClosed", onCloseReset);
        });

        pendingRow.appendChild(el);
      }

      this.updateCommitTile();
    }
  };

  /**********************
   * Inline edit controller (Header + Specifications + Description)
   **********************/
  const INLINE_EDIT = {
    editing: false,
    original: {},
    dirtyKeys: new Set(),

    init(){
      const onEditClick = async () => {
        if (!canSeeAdminNow()) return;
        if (!this.editing){
          this.enterEditMode();
        } else {
          await this.exitEditMode(false);
        }
      };

      $("inlineEditBtn")?.addEventListener("click", onEditClick);
      $("aboutEditBtn")?.addEventListener("click", onEditClick);
      $("topEditBtn")?.addEventListener("click", onEditClick);

      const onSaveClick = async () => {
        if (!canSeeAdminNow()) return;
        await this.saveChanges();
      };

      $("inlineSaveBtn")?.addEventListener("click", onSaveClick);
      $("aboutSaveBtn")?.addEventListener("click", onSaveClick);
      $("topSaveBtn")?.addEventListener("click", onSaveClick);
    },

    enterEditMode(){
      this.editing = true;
      this.setStatus("");
      this.toggleInputs(true);
      this.updateSaveButton();
      this.updateEditButtonLabel();

      syncDescTextareaToDisplay();
      autoResizeTextarea($("descEdit"));
    },

    async exitEditMode(force){
      if (!this.editing) {
        this.resetUI();
        return;
      }

      if (!force && this.dirtyKeys.size > 0){
        const ok = await PAB_CONFIRM.show({
          title: "Discard changes",
          message: "Discard your unsaved changes?",
          okText: "Discard",
          cancelText: "Keep editing",
          danger: true,
          icon: "‚úñ"
        });
        if (!ok) return;
      }

      this.restoreOriginal();
      this.editing = false;
      this.dirtyKeys.clear();
      this.resetUI();
    },

    resetUI(){
      this.toggleInputs(false);
      this.clearChangedMarks();
      this.setStatus("");
      this.updateSaveButton();
      this.updateEditButtonLabel();
    },

    updateEditButtonLabel(){
      const label = this.editing ? "‚úñ Cancel edit" : "‚úèÔ∏è Edit fields";
      const btnA = $("inlineEditBtn");
      const btnB = $("aboutEditBtn");
      const btnC = $("topEditBtn");
      if (btnA) btnA.textContent = label;
      if (btnB) btnB.textContent = label;
      if (btnC) btnC.textContent = label;
    },

    toggleInputs(enable){
      document.querySelectorAll(".spec-input").forEach(inp => {
        inp.disabled = !enable;
        inp.classList.toggle("editing", enable);
      });

      const descText = $("carDescription");
      const desc = $("descEdit");
      if (canSeeAdminNow()){
        if (descText) descText.style.display = enable ? "none" : "";
        if (desc){
          desc.style.display = enable ? "" : "none";
          desc.disabled = !enable;
          desc.classList.toggle("editing", enable);
          if (enable){
            syncDescTextareaToDisplay();
            autoResizeTextarea(desc);
          }
        }
      }

      const tText = $("carTitleText");
      const pText = $("carPriceText");
      const tInp  = $("carTitleInput");
      const pInp  = $("carPriceInput");

      if (canSeeAdminNow()){
        if (tText) tText.style.display = enable ? "none" : "";
        if (pText) pText.style.display = enable ? "none" : "";

        if (tInp)  tInp.style.display  = enable ? "" : "none";
        if (pInp)  pInp.style.display  = enable ? "" : "none";
      }
    },

    setOriginalFromCar(car){
      const keys = [
        "title","price","year","make","model","mileage","engine",
        "transmission","drivetrain","exterior_color","interior_color","vin",
        "history_status","description"
      ];
      this.original = {};
      keys.forEach(k => {
        const v = car?.[k];
        this.original[k] = (v === null || v === undefined) ? "" : String(v);
      });
      this.dirtyKeys.clear();
      this.editing = false;
      this.resetUI();
    },

    bindInputEvents(){
      document.querySelectorAll(".spec-input").forEach(inp => {
        inp.addEventListener("input", () => {
          const key = inp.dataset.key;
          const now = (inp.value ?? "").trim();
          const orig = (this.original[key] ?? "").trim();

          if (now !== orig){
            this.dirtyKeys.add(key);
            inp.classList.add("changed");
            this.showWasForInput(inp, orig);
          } else {
            this.dirtyKeys.delete(key);
            inp.classList.remove("changed");
            this.hideWasForInput(inp);
          }
          this.updateSaveButton();
        });
      });

      const desc = $("descEdit");
      if (desc){
        desc.addEventListener("input", () => {
          autoResizeTextarea(desc);

          const key = "description";
          const now = (desc.value ?? "");
          const orig = (this.original[key] ?? "");

          if (now !== orig){
            this.dirtyKeys.add(key);
            desc.classList.add("changed");
          } else {
            this.dirtyKeys.delete(key);
            desc.classList.remove("changed");
          }
          this.updateSaveButton();
        });
      }
    },

    showWasForInput(inp, orig){
      const wrap = inp.closest(".spec-item");
      if (!wrap) return;
      let was = wrap.querySelector(".spec-was");
      if (!was){
        was = document.createElement("div");
        was.className = "spec-was";
        wrap.querySelector(".spec-value")?.appendChild(was);
      }
      was.textContent = `was: ${orig || "empty"}`;
      was.classList.add("show");
    },
    hideWasForInput(inp){
      const wrap = inp.closest(".spec-item");
      if (!wrap) return;
      const was = wrap.querySelector(".spec-was");
      if (was){
        was.classList.remove("show");
        was.textContent = "";
      }
    },

    clearChangedMarks(){
      document.querySelectorAll(".spec-input").forEach(inp => {
        inp.classList.remove("changed");
        this.hideWasForInput(inp);
      });
      const desc = $("descEdit");
      if (desc) desc.classList.remove("changed");
    },

    restoreOriginal(){
      document.querySelectorAll(".spec-input").forEach(inp => {
        const key = inp.dataset.key;
        const orig = this.original[key] ?? "";
        inp.value = orig;
      });
      const desc = $("descEdit");
      if (desc){
        desc.value = this.original["description"] ?? "";
        autoResizeTextarea(desc);
      }
    },

    updateSaveButton(){
      const saveA = $("inlineSaveBtn");
      const saveB = $("aboutSaveBtn");
      const saveC = $("topSaveBtn");
      const showSave = this.dirtyKeys.size > 0;

      if (saveA) saveA.style.display = showSave ? "" : "none";
      if (saveB) saveB.style.display = showSave ? "" : "none";
      if (saveC) saveC.style.display = showSave ? "" : "none";

      if (saveA) saveA.disabled = !(this.editing && this.dirtyKeys.size > 0);
      if (saveB) saveB.disabled = !(this.editing && this.dirtyKeys.size > 0);
      if (saveC) saveC.disabled = !(this.editing && this.dirtyKeys.size > 0);
    },

    setStatus(text){
      const a = $("inlineEditStatus");
      const b = $("aboutInlineStatus");
      const c = $("topInlineStatus");
      if (a) a.textContent = text || "";
      if (b) b.textContent = text || "";
      if (c) c.textContent = text || "";
    },

    async saveChanges(){
      return await withActionLock("saveChanges", async () => {
      if (!canSeeAdminNow()) return alert("Admin only.");
      const car = window.currentCar;
      if (!car?.id) return alert("Car not loaded yet.");
      if (this.dirtyKeys.size === 0) return;

      const payload = {};
      document.querySelectorAll(".spec-input").forEach(inp => {
        const key = inp.dataset.key;
        if (!this.dirtyKeys.has(key)) return;

        let v = (inp.value ?? "").trim();

        if (key === "year" || key === "mileage" || key === "price"){
          if (v === ""){
            payload[key] = null;
          } else {
            const n = Number(v);
            payload[key] = Number.isFinite(n) ? n : null;
          }
        } else {
          payload[key] = v;
        }
      });

      if (this.dirtyKeys.has("description")){
        const desc = $("descEdit");
        payload.description = (desc?.value ?? "");
      }

      try{
        this.setStatus("Saving...");
        const btnIds = ["inlineSaveBtn","aboutSaveBtn","topSaveBtn","inlineEditBtn","aboutEditBtn","topEditBtn"];
        btnIds.forEach(id => { const b=$(id); if (b){ b.disabled = true; b.style.opacity = "0.7"; b.style.pointerEvents = "none"; }});
        const { error } = await retryAsync(() => db.from("cars").update(payload).eq("id", car.id), 2, 350);
        if (error) throw error;

        // merge changes into in-memory model and re-render without reload
        window.currentCar = window.currentCar || {};
        Object.assign(window.currentCar, payload);
        this.dirtyKeys.clear();
        this.editing = false;
        this.resetUI();
        this.setStatus("Saved.");
        // re-enable buttons
        ["inlineSaveBtn","aboutSaveBtn","topSaveBtn","inlineEditBtn","aboutEditBtn","topEditBtn"].forEach(id => { const b=$(id); if (b){ b.disabled = false; b.style.opacity = ""; b.style.pointerEvents = ""; }});
        try{ renderCar(window.currentCar); }catch(e){ console.warn('renderCar failed', e); }
      } catch(err){
        console.error(err);
        // re-enable buttons
        ["inlineSaveBtn","aboutSaveBtn","topSaveBtn","inlineEditBtn","aboutEditBtn","topEditBtn"].forEach(id => { const b=$(id); if (b){ b.disabled = false; b.style.opacity = ""; b.style.pointerEvents = ""; }});
        this.setStatus("Save failed. Check console.");
        alert("Save failed. Open DevTools Console for details.");
      }
      });
    }
  };

  /**********************
   * load + render car
   **********************/
  async function loadCar(){
    const urlParams = new URLSearchParams(window.location.search);
    const carId = urlParams.get("id");
    if (!carId){ console.error("No car ID in URL"); return; }

    const { data, error } = await db.from("cars").select("*").eq("id", carId).single();
    if (error || !data){ console.error("Failed to load car", error); return; }

    renderCar(data);
  }

  function formatMileage(m){
    if (m === null || m === undefined || m === "") return "";
    const n = Number(m);
    if (!Number.isFinite(n)) return String(m);
    return `${formatNumber(n)} mi`;
  }

function setSpecValue(key, value){
    const item = document.querySelector(`.spec-item[data-key="${key}"]`);
    if (!item) return;

    const valueHost = item.querySelector('[data-role="value"]');
    if (!valueHost) return;

    const isAdminEffective = canSeeAdminNow();
    const raw = (value === null || value === undefined) ? "" : String(value).trim();

    if (!isAdminEffective && raw === ""){
      item.style.display = "none";
      return;
    } else {
      item.style.display = "";
    }

    if (isAdminEffective){
      const inputType = (key === "year" || key === "mileage" || key === "price") ? "number" : "text";
      const safeVal = raw;

      valueHost.innerHTML = `
        <div style="display:flex; flex-direction:column; align-items:flex-end; width:100%;">
          <input class="spec-input" data-key="${key}" type="${inputType}" value="${escapeHtmlAttr(safeVal)}" disabled />
          <div class="spec-was"></div>
        </div>
      `;
      return;
    }

    {
      let display = raw || "‚Äî";
      if (raw !== ""){
        if (key === "mileage") display = `${formatNumber(raw)} mi`;
        if (key === "price") display = `$${formatNumber(raw)}`;
      }
      valueHost.textContent = display;
    }
  }

  function escapeHtmlAttr(str){
    return String(str)
      .replaceAll("&", "&amp;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#39;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;");
  }

  function renderCar(car){
    window.currentCar = car;

    const title = car.title || `${car.year||""} ${car.make||""} ${car.model||""}`.trim();
    const titleText = $("carTitleText");
    const priceText = $("carPriceText");
    const titleInput = $("carTitleInput");
    const priceInput = $("carPriceInput");

    if (titleText) titleText.textContent = title || "Car";
    if (priceText) priceText.textContent = car.price != null ? `$${formatNumber(car.price)}` : "‚Äî";
    if (titleInput) titleInput.value = car.title ?? "";
    if (priceInput) priceInput.value = (car.price ?? "") + "";

    const meta = document.querySelector(".car-meta");
    if (meta) meta.textContent = `${car.mileage != null && car.mileage !== "" ? formatNumber(car.mileage) : "‚Äî"} miles`;

    // About This Car
    const descEl = $("carDescription");
    const descEdit = $("descEdit");
    const descVal = car.description || "No description available.";
    if (descEl) descEl.textContent = descVal;
    if (descEdit){
      descEdit.value = car.description || "";
      syncDescTextareaToDisplay();
      autoResizeTextarea(descEdit);
    }

    // Images
    const mainImgEl = $("mainImg");
    if (mainImgEl){
      const cover = car.cover_image || (Array.isArray(car.images) && car.images[0]) || mainImgEl.src;
      mainImgEl.src = cover ? resolveImageRef(cover) : mainImgEl.src;
      mainImgEl.alt = title || "Car photo";
    }

    const imgs = Array.isArray(car.images) ? car.images : [];
    const galleryImages = imgs.length ? imgs : (car.cover_image ? [car.cover_image] : []);
    PAB_GALLERY.init(galleryImages);

    setSpecValue("year", car.year ?? "");
    setSpecValue("make", car.make ?? "");
    setSpecValue("model", car.model ?? "");
    setSpecValue("mileage", car.mileage ?? "");
    setSpecValue("engine", car.engine ?? "");
    setSpecValue("transmission", car.transmission ?? "");
    setSpecValue("drivetrain", car.drivetrain ?? "");
    setSpecValue("exterior_color", car.exterior_color ?? "");
    setSpecValue("interior_color", car.interior_color ?? "");
    setSpecValue("vin", car.vin ?? "");

    if (!canSeeAdminNow()){
      const item = document.querySelector('.spec-item[data-key="mileage"]');
      if (item && item.style.display !== "none"){
        const host = item.querySelector('[data-role="value"]');
        if (host){
          const raw = (car.mileage === null || car.mileage === undefined) ? "" : String(car.mileage).trim();
          host.textContent = raw ? formatMileage(raw) : "‚Äî";
        }
      }
    }

    if (canSeeAdminNow()){
      INLINE_EDIT.setOriginalFromCar({
        title: car.title ?? "",
        price: car.price ?? "",
        year: car.year ?? "",
        make: car.make ?? "",
        model: car.model ?? "",
        mileage: car.mileage ?? "",
        engine: car.engine ?? "",
        transmission: car.transmission ?? "",
        drivetrain: car.drivetrain ?? "",
        exterior_color: car.exterior_color ?? "",
        interior_color: car.interior_color ?? "",
        vin: car.vin ?? "",
        history_status: car.history_status ?? "",
        description: car.description ?? ""
      });

      INLINE_EDIT.bindInputEvents();
    }

    const adminBox = $("carAdminActions");
    if (adminBox) adminBox.style.display = canSeeAdminNow() ? "" : "none";

    const toggleSoldBtn = $("toggleSoldBtn");
    if (toggleSoldBtn){
      toggleSoldBtn.textContent = (car.status === "sold") ? "Unmark Sold" : "Mark Sold";
      toggleSoldBtn.onclick = async () => {
        if (!canSeeAdminNow()) return;

        const nextStatus = (car.status === "sold") ? "available" : "sold";

        const ok = await PAB_CONFIRM.show({
          title: (nextStatus === "sold") ? "Mark as sold" : "Unmark sold",
          message: (nextStatus === "sold")
            ? "Mark this car as SOLD?"
            : "Unmark SOLD and set this car back to available?",
          okText: (nextStatus === "sold") ? "Mark sold" : "Unmark",
          cancelText: "Cancel",
          danger: false,
          icon: "‚ö†Ô∏è"
        });
        if (!ok) return;

        const { error } = await db.from("cars").update({ status: nextStatus }).eq("id", car.id);
        if (error){ console.error(error); alert("Failed."); return; }
        location.reload();
      };
    }

const delBtn = $("deleteCarBtn");
if (delBtn){
  delBtn.onclick = async () => {
    if (!canSeeAdminNow()) return;

    const car = window.currentCar;
    if (!car?.id) return alert("Car not loaded yet.");

    const ok = await PAB_CONFIRM.show({
      title: "Delete car",
      message: "Delete this car AND all its photos? (no undo)",
      okText: "Delete",
      cancelText: "Cancel",
      danger: true,
      icon: "üóë"
    });
    if (!ok) return;

    try{
      // 1) delete storage first
      await deleteAllCarImagesFromStorage(car);

      // 2) then delete the DB row
      const { error } = await db.from("cars").delete().eq("id", car.id);
      if (error) throw error;

      window.location.href = "../index.html#cars";
    } catch (err){
      console.error(err);
      alert("Delete failed. Check console.");
    }
  };
}

  }

  /**********************
   * DOM wiring
   **********************/
  document.addEventListener("DOMContentLoaded", async () => {
    $("loginBtn")?.addEventListener("click", loginOwner);
    $("logoutBtn")?.addEventListener("click", logoutOwner);

    $("showOwnerLoginBtn")?.addEventListener("click", () => {
      const adminSection = $("adminSection");
      if (adminSection) adminSection.style.display = "";
      if ($("ownerLoginSection")) $("ownerLoginSection").style.display = "none";
      if ($("authLoggedOut")) $("authLoggedOut").style.display = "";
      if ($("authLoggedIn")) $("authLoggedIn").style.display = "none";
    });

    $("viewUserBtn")?.addEventListener("click", () => setViewMode("user"));
    $("viewAdminBtn")?.addEventListener("click", () => setViewMode("admin"));

    updateViewButtons();
    wireAdminModalButtons();
    INLINE_EDIT.init();

    await refreshAuthUI();
    await loadCar();

    window.addEventListener("resize", () => {
      if (INLINE_EDIT.editing) {
        syncDescTextareaToDisplay();
        autoResizeTextarea($("descEdit"));
      }
    });

    db.auth.onAuthStateChange(async () => {
      await refreshAuthUI();
      PAB_GALLERY.updateCoverBadges();
      PAB_GALLERY.injectAdminThumbTiles();
      PAB_GALLERY.renderPendingThumbs();

      INLINE_EDIT.exitEditMode(true);
    });
  });
</script>
</body>
</html>